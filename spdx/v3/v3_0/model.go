// This file was automatically generated by __main__.py. DO NOT MANUALLY MODIFY IT
//
// SPDX-License-Identifier: 0BSD

package v3_0

import (
	"iter"
	"reflect"
	"time"
)

// A class for describing the energy consumption incurred by an AI model in
// different stages of its lifecycle.
type AiEnergyConsumption struct {
	ID string

	// Specifies the amount of energy consumed when finetuning the AI model that is
	// being used in the AI system.
	AiFinetuningEnergyConsumptions AiEnergyConsumptionDescriptionList

	// Specifies the amount of energy consumed during inference time by an AI model
	// that is being used in the AI system.
	AiInferenceEnergyConsumptions AiEnergyConsumptionDescriptionList

	// Specifies the amount of energy consumed when training the AI model that is
	// being used in the AI system.
	AiTrainingEnergyConsumptions AiEnergyConsumptionDescriptionList
}

func castAiEnergyConsumption(o any) *AiEnergyConsumption {
	if o, ok := o.(AnyAiEnergyConsumption); ok {
		return o.asAiEnergyConsumption()
	}
	return nil
}

func (o *AiEnergyConsumption) asAiEnergyConsumption() *AiEnergyConsumption {
	return o
}

type AnyAiEnergyConsumption interface {
	asAiEnergyConsumption() *AiEnergyConsumption
}

type AiEnergyConsumptionList []AnyAiEnergyConsumption

func (o *AiEnergyConsumptionList) Append(values ...AnyAiEnergyConsumption) {
	*o = append(*o, values...)
}
func (o *AiEnergyConsumptionList) Remove(value AnyAiEnergyConsumption) { remove(o, value) }

func (o *AiEnergyConsumptionList) AiEnergyConsumptionIter() iter.Seq2[AnyAiEnergyConsumption, *AiEnergyConsumption] {
	return typeIter(*o, castAiEnergyConsumption)
}

// The class that helps note down the quantity of energy consumption and the unit
// used for measurement.
type AiEnergyConsumptionDescription struct {
	ID string

	// Represents the energy quantity.
	AiEnergyQuantity float64
	// Specifies the unit in which energy is measured.
	AiEnergyUnit AiEnergyUnitType
}

func castAiEnergyConsumptionDescription(o any) *AiEnergyConsumptionDescription {
	if o, ok := o.(AnyAiEnergyConsumptionDescription); ok {
		return o.asAiEnergyConsumptionDescription()
	}
	return nil
}

func (o *AiEnergyConsumptionDescription) asAiEnergyConsumptionDescription() *AiEnergyConsumptionDescription {
	return o
}

type AnyAiEnergyConsumptionDescription interface {
	asAiEnergyConsumptionDescription() *AiEnergyConsumptionDescription
}

type AiEnergyConsumptionDescriptionList []AnyAiEnergyConsumptionDescription

func (o *AiEnergyConsumptionDescriptionList) Append(values ...AnyAiEnergyConsumptionDescription) {
	*o = append(*o, values...)
}
func (o *AiEnergyConsumptionDescriptionList) Remove(value AnyAiEnergyConsumptionDescription) {
	remove(o, value)
}

func (o *AiEnergyConsumptionDescriptionList) AiEnergyConsumptionDescriptionIter() iter.Seq2[AnyAiEnergyConsumptionDescription, *AiEnergyConsumptionDescription] {
	return typeIter(*o, castAiEnergyConsumptionDescription)
}

// Specifies the unit of energy consumption.
type AiEnergyUnitType struct {
	ID string
}

// Kilowatt-hour.
var AiEnergyUnitType_KilowattHour = AiEnergyUnitType{ID: "https://spdx.org/rdf/3.0.1/terms/AI/EnergyUnitType/kilowattHour"}

// Megajoule.
var AiEnergyUnitType_Megajoule = AiEnergyUnitType{ID: "https://spdx.org/rdf/3.0.1/terms/AI/EnergyUnitType/megajoule"}

// Any other units of energy measurement.
var AiEnergyUnitType_Other = AiEnergyUnitType{ID: "https://spdx.org/rdf/3.0.1/terms/AI/EnergyUnitType/other"}

// Specifies the safety risk level.
type AiSafetyRiskAssessmentType struct {
	ID string
}

// The second-highest level of risk posed by an AI system.
var AiSafetyRiskAssessmentType_High = AiSafetyRiskAssessmentType{ID: "https://spdx.org/rdf/3.0.1/terms/AI/SafetyRiskAssessmentType/high"}

// Low/no risk is posed by an AI system.
var AiSafetyRiskAssessmentType_Low = AiSafetyRiskAssessmentType{ID: "https://spdx.org/rdf/3.0.1/terms/AI/SafetyRiskAssessmentType/low"}

// The third-highest level of risk posed by an AI system.
var AiSafetyRiskAssessmentType_Medium = AiSafetyRiskAssessmentType{ID: "https://spdx.org/rdf/3.0.1/terms/AI/SafetyRiskAssessmentType/medium"}

// The highest level of risk posed by an AI system.
var AiSafetyRiskAssessmentType_Serious = AiSafetyRiskAssessmentType{ID: "https://spdx.org/rdf/3.0.1/terms/AI/SafetyRiskAssessmentType/serious"}

// Specifies the type of an annotation.
type AnnotationType struct {
	ID string
}

// Used to store extra information about an Element which is not part of a review (e.g. extra information provided during the creation of the Element).
var AnnotationType_Other = AnnotationType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/AnnotationType/other"}

// Used when someone reviews the Element.
var AnnotationType_Review = AnnotationType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/AnnotationType/review"}

// Provides information about the creation of the Element.
type CreationInfo struct {
	ID string

	// Provide consumers with comments by the creator of the Element about the
	// Element.
	Comment string
	// Identifies when the Element was originally created.
	Created time.Time
	// Identifies who or what created the Element.
	CreatedBys AgentList

	// Identifies the tooling that was used during the creation of the Element.
	CreatedUsings ToolList

	// Provides a reference number that can be used to understand how to parse and
	// interpret an Element.
	SpecVersion string
}

func castCreationInfo(o any) *CreationInfo {
	if o, ok := o.(AnyCreationInfo); ok {
		return o.asCreationInfo()
	}
	return nil
}

func (o *CreationInfo) asCreationInfo() *CreationInfo {
	return o
}

type AnyCreationInfo interface {
	asCreationInfo() *CreationInfo
}

type CreationInfoList []AnyCreationInfo

func (o *CreationInfoList) Append(values ...AnyCreationInfo) { *o = append(*o, values...) }
func (o *CreationInfoList) Remove(value AnyCreationInfo)     { remove(o, value) }

func (o *CreationInfoList) CreationInfoIter() iter.Seq2[AnyCreationInfo, *CreationInfo] {
	return typeIter(*o, castCreationInfo)
}

// A key with an associated value.
type DictionaryEntry struct {
	ID string

	// A key used in a generic key-value pair.
	Key string
	// A value used in a generic key-value pair.
	Value string
}

func castDictionaryEntry(o any) *DictionaryEntry {
	if o, ok := o.(AnyDictionaryEntry); ok {
		return o.asDictionaryEntry()
	}
	return nil
}

func (o *DictionaryEntry) asDictionaryEntry() *DictionaryEntry {
	return o
}

type AnyDictionaryEntry interface {
	asDictionaryEntry() *DictionaryEntry
}

type DictionaryEntryList []AnyDictionaryEntry

func (o *DictionaryEntryList) Append(values ...AnyDictionaryEntry) { *o = append(*o, values...) }
func (o *DictionaryEntryList) Remove(value AnyDictionaryEntry)     { remove(o, value) }

func (o *DictionaryEntryList) DictionaryEntryIter() iter.Seq2[AnyDictionaryEntry, *DictionaryEntry] {
	return typeIter(*o, castDictionaryEntry)
}

// Base domain class from which all other SPDX-3.0 domain classes derive.
type Element struct {
	ID string

	// Provide consumers with comments by the creator of the Element about the
	// Element.
	Comment string
	// Provides information about the creation of the Element.
	CreationInfo AnyCreationInfo

	// Provides a detailed description of the Element.
	Description string
	// Specifies an Extension characterization of some aspect of an Element.
	Extensions ExtensionExtensionList

	// Provides a reference to a resource outside the scope of SPDX-3.0 content
	// that uniquely identifies an Element.
	ExternalIdentifiers ExternalIdentifierList

	// Points to a resource outside the scope of the SPDX-3.0 content
	// that provides additional characteristics of an Element.
	ExternalRefs ExternalRefList

	// Identifies the name of an Element as designated by the creator.
	Name string
	// A short description of an Element.
	Summary string
	// Provides an IntegrityMethod with which the integrity of an Element can be
	// asserted.
	VerifiedUsings IntegrityMethodList
}

func castElement(o any) *Element {
	if o, ok := o.(AnyElement); ok {
		return o.asElement()
	}
	return nil
}

func (o *Element) asElement() *Element {
	return o
}

type AnyElement interface {
	asElement() *Element
}

type ElementList []AnyElement

func (o *ElementList) Append(values ...AnyElement) { *o = append(*o, values...) }
func (o *ElementList) Remove(value AnyElement)     { remove(o, value) }

func (o *ElementList) ElementIter() iter.Seq2[AnyElement, *Element] { return typeIter(*o, castElement) }
func (o *ElementList) ElementCollectionIter() iter.Seq2[AnyElement, *ElementCollection] {
	return typeIter(*o, castElementCollection)
}
func (o *ElementList) IndividualElementIter() iter.Seq2[AnyElement, *IndividualElement] {
	return typeIter(*o, castIndividualElement)
}
func (o *ElementList) RelationshipIter() iter.Seq2[AnyElement, *Relationship] {
	return typeIter(*o, castRelationship)
}
func (o *ElementList) SpdxDocumentIter() iter.Seq2[AnyElement, *SpdxDocument] {
	return typeIter(*o, castSpdxDocument)
}
func (o *ElementList) ToolIter() iter.Seq2[AnyElement, *Tool] { return typeIter(*o, castTool) }
func (o *ElementList) ExpandedlicensingLicenseAdditionIter() iter.Seq2[AnyElement, *ExpandedlicensingLicenseAddition] {
	return typeIter(*o, castExpandedlicensingLicenseAddition)
}
func (o *ElementList) ExpandedlicensingListedLicenseExceptionIter() iter.Seq2[AnyElement, *ExpandedlicensingListedLicenseException] {
	return typeIter(*o, castExpandedlicensingListedLicenseException)
}
func (o *ElementList) SecurityVulnAssessmentRelationshipIter() iter.Seq2[AnyElement, *SecurityVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVulnAssessmentRelationship)
}
func (o *ElementList) SimplelicensingAnyLicenseInfoIter() iter.Seq2[AnyElement, *SimplelicensingAnyLicenseInfo] {
	return typeIter(*o, castSimplelicensingAnyLicenseInfo)
}
func (o *ElementList) SimplelicensingLicenseExpressionIter() iter.Seq2[AnyElement, *SimplelicensingLicenseExpression] {
	return typeIter(*o, castSimplelicensingLicenseExpression)
}
func (o *ElementList) SimplelicensingSimpleLicensingTextIter() iter.Seq2[AnyElement, *SimplelicensingSimpleLicensingText] {
	return typeIter(*o, castSimplelicensingSimpleLicensingText)
}
func (o *ElementList) BuildBuildIter() iter.Seq2[AnyElement, *BuildBuild] {
	return typeIter(*o, castBuildBuild)
}
func (o *ElementList) AgentIter() iter.Seq2[AnyElement, *Agent] { return typeIter(*o, castAgent) }
func (o *ElementList) AnnotationIter() iter.Seq2[AnyElement, *Annotation] {
	return typeIter(*o, castAnnotation)
}
func (o *ElementList) ArtifactIter() iter.Seq2[AnyElement, *Artifact] {
	return typeIter(*o, castArtifact)
}
func (o *ElementList) BundleIter() iter.Seq2[AnyElement, *Bundle] { return typeIter(*o, castBundle) }
func (o *ElementList) LifecycleScopedRelationshipIter() iter.Seq2[AnyElement, *LifecycleScopedRelationship] {
	return typeIter(*o, castLifecycleScopedRelationship)
}
func (o *ElementList) OrganizationIter() iter.Seq2[AnyElement, *Organization] {
	return typeIter(*o, castOrganization)
}
func (o *ElementList) PersonIter() iter.Seq2[AnyElement, *Person] { return typeIter(*o, castPerson) }
func (o *ElementList) SoftwareAgentIter() iter.Seq2[AnyElement, *SoftwareAgent] {
	return typeIter(*o, castSoftwareAgent)
}
func (o *ElementList) ExpandedlicensingConjunctiveLicenseSetIter() iter.Seq2[AnyElement, *ExpandedlicensingConjunctiveLicenseSet] {
	return typeIter(*o, castExpandedlicensingConjunctiveLicenseSet)
}
func (o *ElementList) ExpandedlicensingCustomLicenseAdditionIter() iter.Seq2[AnyElement, *ExpandedlicensingCustomLicenseAddition] {
	return typeIter(*o, castExpandedlicensingCustomLicenseAddition)
}
func (o *ElementList) ExpandedlicensingDisjunctiveLicenseSetIter() iter.Seq2[AnyElement, *ExpandedlicensingDisjunctiveLicenseSet] {
	return typeIter(*o, castExpandedlicensingDisjunctiveLicenseSet)
}
func (o *ElementList) ExpandedlicensingExtendableLicenseIter() iter.Seq2[AnyElement, *ExpandedlicensingExtendableLicense] {
	return typeIter(*o, castExpandedlicensingExtendableLicense)
}
func (o *ElementList) ExpandedlicensingIndividualLicensingInfoIter() iter.Seq2[AnyElement, *ExpandedlicensingIndividualLicensingInfo] {
	return typeIter(*o, castExpandedlicensingIndividualLicensingInfo)
}
func (o *ElementList) ExpandedlicensingLicenseIter() iter.Seq2[AnyElement, *ExpandedlicensingLicense] {
	return typeIter(*o, castExpandedlicensingLicense)
}
func (o *ElementList) ExpandedlicensingListedLicenseIter() iter.Seq2[AnyElement, *ExpandedlicensingListedLicense] {
	return typeIter(*o, castExpandedlicensingListedLicense)
}
func (o *ElementList) ExpandedlicensingOrLaterOperatorIter() iter.Seq2[AnyElement, *ExpandedlicensingOrLaterOperator] {
	return typeIter(*o, castExpandedlicensingOrLaterOperator)
}
func (o *ElementList) ExpandedlicensingWithAdditionOperatorIter() iter.Seq2[AnyElement, *ExpandedlicensingWithAdditionOperator] {
	return typeIter(*o, castExpandedlicensingWithAdditionOperator)
}
func (o *ElementList) SecurityCvssV2VulnAssessmentRelationshipIter() iter.Seq2[AnyElement, *SecurityCvssV2VulnAssessmentRelationship] {
	return typeIter(*o, castSecurityCvssV2VulnAssessmentRelationship)
}
func (o *ElementList) SecurityCvssV3VulnAssessmentRelationshipIter() iter.Seq2[AnyElement, *SecurityCvssV3VulnAssessmentRelationship] {
	return typeIter(*o, castSecurityCvssV3VulnAssessmentRelationship)
}
func (o *ElementList) SecurityCvssV4VulnAssessmentRelationshipIter() iter.Seq2[AnyElement, *SecurityCvssV4VulnAssessmentRelationship] {
	return typeIter(*o, castSecurityCvssV4VulnAssessmentRelationship)
}
func (o *ElementList) SecurityEpssVulnAssessmentRelationshipIter() iter.Seq2[AnyElement, *SecurityEpssVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityEpssVulnAssessmentRelationship)
}
func (o *ElementList) SecurityExploitCatalogVulnAssessmentRelationshipIter() iter.Seq2[AnyElement, *SecurityExploitCatalogVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityExploitCatalogVulnAssessmentRelationship)
}
func (o *ElementList) SecuritySsvcVulnAssessmentRelationshipIter() iter.Seq2[AnyElement, *SecuritySsvcVulnAssessmentRelationship] {
	return typeIter(*o, castSecuritySsvcVulnAssessmentRelationship)
}
func (o *ElementList) SecurityVexVulnAssessmentRelationshipIter() iter.Seq2[AnyElement, *SecurityVexVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexVulnAssessmentRelationship)
}
func (o *ElementList) SecurityVulnerabilityIter() iter.Seq2[AnyElement, *SecurityVulnerability] {
	return typeIter(*o, castSecurityVulnerability)
}
func (o *ElementList) SoftwareSoftwareArtifactIter() iter.Seq2[AnyElement, *SoftwareSoftwareArtifact] {
	return typeIter(*o, castSoftwareSoftwareArtifact)
}
func (o *ElementList) BomIter() iter.Seq2[AnyElement, *Bom] { return typeIter(*o, castBom) }
func (o *ElementList) ExpandedlicensingCustomLicenseIter() iter.Seq2[AnyElement, *ExpandedlicensingCustomLicense] {
	return typeIter(*o, castExpandedlicensingCustomLicense)
}
func (o *ElementList) SecurityVexAffectedVulnAssessmentRelationshipIter() iter.Seq2[AnyElement, *SecurityVexAffectedVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexAffectedVulnAssessmentRelationship)
}
func (o *ElementList) SecurityVexFixedVulnAssessmentRelationshipIter() iter.Seq2[AnyElement, *SecurityVexFixedVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexFixedVulnAssessmentRelationship)
}
func (o *ElementList) SecurityVexNotAffectedVulnAssessmentRelationshipIter() iter.Seq2[AnyElement, *SecurityVexNotAffectedVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexNotAffectedVulnAssessmentRelationship)
}
func (o *ElementList) SecurityVexUnderInvestigationVulnAssessmentRelationshipIter() iter.Seq2[AnyElement, *SecurityVexUnderInvestigationVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexUnderInvestigationVulnAssessmentRelationship)
}
func (o *ElementList) SoftwareFileIter() iter.Seq2[AnyElement, *SoftwareFile] {
	return typeIter(*o, castSoftwareFile)
}
func (o *ElementList) SoftwarePackageIter() iter.Seq2[AnyElement, *SoftwarePackage] {
	return typeIter(*o, castSoftwarePackage)
}
func (o *ElementList) SoftwareSbomIter() iter.Seq2[AnyElement, *SoftwareSbom] {
	return typeIter(*o, castSoftwareSbom)
}
func (o *ElementList) SoftwareSnippetIter() iter.Seq2[AnyElement, *SoftwareSnippet] {
	return typeIter(*o, castSoftwareSnippet)
}
func (o *ElementList) AiAIPackageIter() iter.Seq2[AnyElement, *AiAIPackage] {
	return typeIter(*o, castAiAIPackage)
}
func (o *ElementList) DatasetDatasetPackageIter() iter.Seq2[AnyElement, *DatasetDatasetPackage] {
	return typeIter(*o, castDatasetDatasetPackage)
}

// A collection of Elements, not necessarily with unifying context.
type ElementCollection struct {
	Element

	// Refers to one or more Elements that are part of an ElementCollection.
	Elements ElementList

	// Describes one a profile which the creator of this ElementCollection intends to
	// conform to.
	ProfileConformances []ProfileIdentifierType
	// This property is used to denote the root Element(s) of a tree of elements contained in a BOM.
	RootElements ElementList
}

func castElementCollection(o any) *ElementCollection {
	if o, ok := o.(AnyElementCollection); ok {
		return o.asElementCollection()
	}
	return nil
}

func (o *ElementCollection) asElementCollection() *ElementCollection {
	return o
}

type AnyElementCollection interface {
	AnyElement
	asElementCollection() *ElementCollection
}

type ElementCollectionList []AnyElementCollection

func (o *ElementCollectionList) Append(values ...AnyElementCollection) { *o = append(*o, values...) }
func (o *ElementCollectionList) Remove(value AnyElementCollection)     { remove(o, value) }

func (o *ElementCollectionList) ElementCollectionIter() iter.Seq2[AnyElementCollection, *ElementCollection] {
	return typeIter(*o, castElementCollection)
}
func (o *ElementCollectionList) SpdxDocumentIter() iter.Seq2[AnyElementCollection, *SpdxDocument] {
	return typeIter(*o, castSpdxDocument)
}
func (o *ElementCollectionList) BundleIter() iter.Seq2[AnyElementCollection, *Bundle] {
	return typeIter(*o, castBundle)
}
func (o *ElementCollectionList) BomIter() iter.Seq2[AnyElementCollection, *Bom] {
	return typeIter(*o, castBom)
}
func (o *ElementCollectionList) SoftwareSbomIter() iter.Seq2[AnyElementCollection, *SoftwareSbom] {
	return typeIter(*o, castSoftwareSbom)
}

// A reference to a resource identifier defined outside the scope of SPDX-3.0 content that uniquely identifies an Element.
type ExternalIdentifier struct {
	ID string

	// Provide consumers with comments by the creator of the Element about the
	// Element.
	Comment string
	// Specifies the type of the external identifier.
	ExternalIdentifierType ExternalIdentifierType
	// Uniquely identifies an external element.
	Identifier string
	// Provides the location for more information regarding an external identifier.
	IdentifierLocators []string
	// An entity that is authorized to issue identification credentials.
	IssuingAuthority string
}

func castExternalIdentifier(o any) *ExternalIdentifier {
	if o, ok := o.(AnyExternalIdentifier); ok {
		return o.asExternalIdentifier()
	}
	return nil
}

func (o *ExternalIdentifier) asExternalIdentifier() *ExternalIdentifier {
	return o
}

type AnyExternalIdentifier interface {
	asExternalIdentifier() *ExternalIdentifier
}

type ExternalIdentifierList []AnyExternalIdentifier

func (o *ExternalIdentifierList) Append(values ...AnyExternalIdentifier) { *o = append(*o, values...) }
func (o *ExternalIdentifierList) Remove(value AnyExternalIdentifier)     { remove(o, value) }

func (o *ExternalIdentifierList) ExternalIdentifierIter() iter.Seq2[AnyExternalIdentifier, *ExternalIdentifier] {
	return typeIter(*o, castExternalIdentifier)
}

// Specifies the type of an external identifier.
type ExternalIdentifierType struct {
	ID string
}

// [Common Platform Enumeration Specification 2.2](https://cpe.mitre.org/files/cpe-specification_2.2.pdf)
var ExternalIdentifierType_Cpe22 = ExternalIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalIdentifierType/cpe22"}

// [Common Platform Enumeration: Naming Specification Version 2.3](https://csrc.nist.gov/publications/detail/nistir/7695/final)
var ExternalIdentifierType_Cpe23 = ExternalIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalIdentifierType/cpe23"}

// Common Vulnerabilities and Exposures identifiers, an identifier for a specific software flaw defined within the official CVE Dictionary and that conforms to the [CVE specification](https://csrc.nist.gov/glossary/term/cve_id).
var ExternalIdentifierType_Cve = ExternalIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalIdentifierType/cve"}

// Email address, as defined in [RFC 3696](https://datatracker.ietf.org/doc/rfc3986/) Section 3.
var ExternalIdentifierType_Email = ExternalIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalIdentifierType/email"}

// [Gitoid](https://www.iana.org/assignments/uri-schemes/prov/gitoid), stands for [Git Object ID](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects). A gitoid of type blob is a unique hash of a binary artifact. A gitoid may represent either an [Artifact Identifier](https://github.com/omnibor/spec/blob/eb1ee5c961c16215eb8709b2975d193a2007a35d/spec/SPEC.md#artifact-identifier-types) for the software artifact or an [Input Manifest Identifier](https://github.com/omnibor/spec/blob/eb1ee5c961c16215eb8709b2975d193a2007a35d/spec/SPEC.md#input-manifest-identifier) for the software artifact's associated [Artifact Input Manifest](https://github.com/omnibor/spec/blob/eb1ee5c961c16215eb8709b2975d193a2007a35d/spec/SPEC.md#artifact-input-manifest); this ambiguity exists because the Artifact Input Manifest is itself an artifact, and the gitoid of that artifact is its valid identifier. Gitoids calculated on software artifacts (Snippet, File, or Package Elements) should be recorded in the SPDX 3.0 SoftwareArtifact's contentIdentifier property. Gitoids calculated on the Artifact Input Manifest (Input Manifest Identifier) should be recorded in the SPDX 3.0 Element's externalIdentifier property. See [OmniBOR Specification](https://github.com/omnibor/spec/), a minimalistic specification for describing software [Artifact Dependency Graphs](https://github.com/omnibor/spec/blob/eb1ee5c961c16215eb8709b2975d193a2007a35d/spec/SPEC.md#artifact-dependency-graph-adg).
var ExternalIdentifierType_Gitoid = ExternalIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalIdentifierType/gitoid"}

// Used when the type does not match any of the other options.
var ExternalIdentifierType_Other = ExternalIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalIdentifierType/other"}

// Package URL, as defined in the corresponding [Annex](../../../annexes/pkg-url-specification.md) of this specification.
var ExternalIdentifierType_PackageUrl = ExternalIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalIdentifierType/packageUrl"}

// Used when there is a security related identifier of unspecified type.
var ExternalIdentifierType_SecurityOther = ExternalIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalIdentifierType/securityOther"}

// SoftWare Hash IDentifier, a persistent intrinsic identifier for digital artifacts, such as files, trees (also known as directories or folders), commits, and other objects typically found in version control systems. The format of the identifiers is defined in the [SWHID specification](https://www.swhid.org/specification/v1.1/4.Syntax) (ISO/IEC DIS 18670). They typically look like `swh:1:cnt:94a9ed024d3859793618152ea559a168bbcbb5e2`.
var ExternalIdentifierType_Swhid = ExternalIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalIdentifierType/swhid"}

// Concise Software Identification (CoSWID) tag, as defined in [RFC 9393](https://datatracker.ietf.org/doc/rfc9393/) Section 2.3.
var ExternalIdentifierType_Swid = ExternalIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalIdentifierType/swid"}

// [Uniform Resource Identifier (URI) Schemes](https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml). The scheme used in order to locate a resource.
var ExternalIdentifierType_UrlScheme = ExternalIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalIdentifierType/urlScheme"}

// A map of Element identifiers that are used within an SpdxDocument but defined
// external to that SpdxDocument.
type ExternalMap struct {
	ID string

	// Artifact representing a serialization instance of SPDX data containing the
	// definition of a particular Element.
	DefiningArtifact AnyArtifact

	// Identifies an external Element used within an SpdxDocument but defined
	// external to that SpdxDocument.
	ExternalSpdxId string
	// Provides an indication of where to retrieve an external Element.
	LocationHint string
	// Provides an IntegrityMethod with which the integrity of an Element can be
	// asserted.
	VerifiedUsings IntegrityMethodList
}

func castExternalMap(o any) *ExternalMap {
	if o, ok := o.(AnyExternalMap); ok {
		return o.asExternalMap()
	}
	return nil
}

func (o *ExternalMap) asExternalMap() *ExternalMap {
	return o
}

type AnyExternalMap interface {
	asExternalMap() *ExternalMap
}

type ExternalMapList []AnyExternalMap

func (o *ExternalMapList) Append(values ...AnyExternalMap) { *o = append(*o, values...) }
func (o *ExternalMapList) Remove(value AnyExternalMap)     { remove(o, value) }

func (o *ExternalMapList) ExternalMapIter() iter.Seq2[AnyExternalMap, *ExternalMap] {
	return typeIter(*o, castExternalMap)
}

// A reference to a resource outside the scope of SPDX-3.0 content related to an Element.
type ExternalRef struct {
	ID string

	// Provide consumers with comments by the creator of the Element about the
	// Element.
	Comment string
	// Provides information about the content type of an Element or a Property.
	ContentType string
	// Specifies the type of the external reference.
	ExternalRefType ExternalRefType
	// Provides the location of an external reference.
	Locators []string
}

func castExternalRef(o any) *ExternalRef {
	if o, ok := o.(AnyExternalRef); ok {
		return o.asExternalRef()
	}
	return nil
}

func (o *ExternalRef) asExternalRef() *ExternalRef {
	return o
}

type AnyExternalRef interface {
	asExternalRef() *ExternalRef
}

type ExternalRefList []AnyExternalRef

func (o *ExternalRefList) Append(values ...AnyExternalRef) { *o = append(*o, values...) }
func (o *ExternalRefList) Remove(value AnyExternalRef)     { remove(o, value) }

func (o *ExternalRefList) ExternalRefIter() iter.Seq2[AnyExternalRef, *ExternalRef] {
	return typeIter(*o, castExternalRef)
}

// Specifies the type of an external reference.
type ExternalRefType struct {
	ID string
}

// A reference to an alternative download location.
var ExternalRefType_AltDownloadLocation = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/altDownloadLocation"}

// A reference to an alternative web page.
var ExternalRefType_AltWebPage = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/altWebPage"}

// A reference to binary artifacts related to a package.
var ExternalRefType_BinaryArtifact = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/binaryArtifact"}

// A reference to a Bower package. The package locator format, looks like `package#version`, is defined in the "install" section of [Bower API documentation](https://bower.io/docs/api/#install).
var ExternalRefType_Bower = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/bower"}

// A reference build metadata related to a published package.
var ExternalRefType_BuildMeta = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/buildMeta"}

// A reference build system used to create or publish the package.
var ExternalRefType_BuildSystem = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/buildSystem"}

// A reference to a certification report for a package from an accredited/independent body.
var ExternalRefType_CertificationReport = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/certificationReport"}

// A reference to the instant messaging system used by the maintainer for a package.
var ExternalRefType_Chat = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/chat"}

// A reference to a Software Composition Analysis (SCA) report.
var ExternalRefType_ComponentAnalysisReport = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/componentAnalysisReport"}

// [Common Weakness Enumeration](https://csrc.nist.gov/glossary/term/common_weakness_enumeration). A reference to a source of software flaw defined within the official [CWE List](https://cwe.mitre.org/data/) that conforms to the [CWE specification](https://cwe.mitre.org/).
var ExternalRefType_Cwe = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/cwe"}

// A reference to the documentation for a package.
var ExternalRefType_Documentation = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/documentation"}

// A reference to a dynamic analysis report for a package.
var ExternalRefType_DynamicAnalysisReport = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/dynamicAnalysisReport"}

// A reference to the End Of Sale (EOS) and/or End Of Life (EOL) information related to a package.
var ExternalRefType_EolNotice = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/eolNotice"}

// A reference to a export control assessment for a package.
var ExternalRefType_ExportControlAssessment = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/exportControlAssessment"}

// A reference to funding information related to a package.
var ExternalRefType_Funding = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/funding"}

// A reference to the issue tracker for a package.
var ExternalRefType_IssueTracker = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/issueTracker"}

// A reference to additional license information related to an artifact.
var ExternalRefType_License = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/license"}

// A reference to the mailing list used by the maintainer for a package.
var ExternalRefType_MailingList = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/mailingList"}

// A reference to a Maven repository artifact. The artifact locator format is defined in the [Maven documentation](https://maven.apache.org/guides/mini/guide-naming-conventions.html) and looks like `groupId:artifactId[:version]`.
var ExternalRefType_MavenCentral = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/mavenCentral"}

// A reference to metrics related to package such as OpenSSF scorecards.
var ExternalRefType_Metrics = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/metrics"}

// A reference to an npm package. The package locator format is defined in the [npm documentation](https://docs.npmjs.com/cli/v10/configuring-npm/package-json) and looks like `package@version`.
var ExternalRefType_Npm = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/npm"}

// A reference to a NuGet package. The package locator format is defined in the [NuGet documentation](https://docs.nuget.org) and looks like `package/version`.
var ExternalRefType_Nuget = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/nuget"}

// Used when the type does not match any of the other options.
var ExternalRefType_Other = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/other"}

// A reference to a privacy assessment for a package.
var ExternalRefType_PrivacyAssessment = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/privacyAssessment"}

// A reference to additional product metadata such as reference within organization's product catalog.
var ExternalRefType_ProductMetadata = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/productMetadata"}

// A reference to a purchase order for a package.
var ExternalRefType_PurchaseOrder = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/purchaseOrder"}

// A reference to a quality assessment for a package.
var ExternalRefType_QualityAssessmentReport = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/qualityAssessmentReport"}

// A reference to a published list of releases for a package.
var ExternalRefType_ReleaseHistory = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/releaseHistory"}

// A reference to the release notes for a package.
var ExternalRefType_ReleaseNotes = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/releaseNotes"}

// A reference to a risk assessment for a package.
var ExternalRefType_RiskAssessment = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/riskAssessment"}

// A reference to a runtime analysis report for a package.
var ExternalRefType_RuntimeAnalysisReport = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/runtimeAnalysisReport"}

// A reference to information assuring that the software is developed using security practices as defined by [NIST SP 800-218 Secure Software Development Framework (SSDF) Version 1.1](https://csrc.nist.gov/pubs/sp/800/218/final) or [CISA Secure Software Development Attestation Form](https://www.cisa.gov/resources-tools/resources/secure-software-development-attestation-form).
var ExternalRefType_SecureSoftwareAttestation = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/secureSoftwareAttestation"}

// A reference to the security adversary model for a package.
var ExternalRefType_SecurityAdversaryModel = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/securityAdversaryModel"}

// A reference to a published security advisory (where advisory as defined per [ISO 29147:2018](https://www.iso.org/standard/72311.html)) that may affect one or more elements, e.g., vendor advisories or specific NVD entries.
var ExternalRefType_SecurityAdvisory = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/securityAdvisory"}

// A reference to the patch or source code that fixes a vulnerability.
var ExternalRefType_SecurityFix = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/securityFix"}

// A reference to related security information of unspecified type.
var ExternalRefType_SecurityOther = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/securityOther"}

// A reference to a [penetration test](https://en.wikipedia.org/wiki/Penetration_test) report for a package.
var ExternalRefType_SecurityPenTestReport = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/securityPenTestReport"}

// A reference to instructions for reporting newly discovered security vulnerabilities for a package.
var ExternalRefType_SecurityPolicy = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/securityPolicy"}

// A reference the [security threat model](https://en.wikipedia.org/wiki/Threat_model) for a package.
var ExternalRefType_SecurityThreatModel = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/securityThreatModel"}

// A reference to a social media channel for a package.
var ExternalRefType_SocialMedia = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/socialMedia"}

// A reference to an artifact containing the sources for a package.
var ExternalRefType_SourceArtifact = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/sourceArtifact"}

// A reference to a static analysis report for a package.
var ExternalRefType_StaticAnalysisReport = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/staticAnalysisReport"}

// A reference to the software support channel or other support information for a package.
var ExternalRefType_Support = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/support"}

// A reference to a version control system related to a software artifact.
var ExternalRefType_Vcs = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/vcs"}

// A reference to a Vulnerability Disclosure Report (VDR) which provides the software supplier's analysis and findings describing the impact (or lack of impact) that reported vulnerabilities have on packages or products in the supplier's SBOM as defined in [NIST SP 800-161 Cybersecurity Supply Chain Risk Management Practices for Systems and Organizations](https://csrc.nist.gov/pubs/sp/800/161/r1/final).
var ExternalRefType_VulnerabilityDisclosureReport = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/vulnerabilityDisclosureReport"}

// A reference to a Vulnerability Exploitability eXchange (VEX) statement which provides information on whether a product is impacted by a specific vulnerability in an included package and, if affected, whether there are actions recommended to remediate. See also [NTIA VEX one-page summary](https://ntia.gov/files/ntia/publications/vex_one-page_summary.pdf).
var ExternalRefType_VulnerabilityExploitabilityAssessment = ExternalRefType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ExternalRefType/vulnerabilityExploitabilityAssessment"}

// A mathematical algorithm that maps data of arbitrary size to a bit string.
type HashAlgorithm struct {
	ID string
}

// Adler-32 checksum is part of the widely used zlib compression library as defined in [RFC 1950](https://datatracker.ietf.org/doc/rfc1950/) Section 2.3.
var HashAlgorithm_Adler32 = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/adler32"}

// BLAKE2b algorithm with a digest size of 256, as defined in [RFC 7693](https://datatracker.ietf.org/doc/rfc7693/) Section 4.
var HashAlgorithm_Blake2b256 = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/blake2b256"}

// BLAKE2b algorithm with a digest size of 384, as defined in [RFC 7693](https://datatracker.ietf.org/doc/rfc7693/) Section 4.
var HashAlgorithm_Blake2b384 = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/blake2b384"}

// BLAKE2b algorithm with a digest size of 512, as defined in [RFC 7693](https://datatracker.ietf.org/doc/rfc7693/) Section 4.
var HashAlgorithm_Blake2b512 = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/blake2b512"}

// [BLAKE3](https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf)
var HashAlgorithm_Blake3 = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/blake3"}

// [Dilithium](https://pq-crystals.org/dilithium/)
var HashAlgorithm_CrystalsDilithium = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/crystalsDilithium"}

// [Kyber](https://pq-crystals.org/kyber/)
var HashAlgorithm_CrystalsKyber = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/crystalsKyber"}

// [FALCON](https://falcon-sign.info/falcon.pdf)
var HashAlgorithm_Falcon = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/falcon"}

// MD2 message-digest algorithm, as defined in [RFC 1319](https://datatracker.ietf.org/doc/rfc1319/).
var HashAlgorithm_Md2 = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/md2"}

// MD4 message-digest algorithm, as defined in [RFC 1186](https://datatracker.ietf.org/doc/rfc1186/).
var HashAlgorithm_Md4 = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/md4"}

// MD5 message-digest algorithm, as defined in [RFC 1321](https://datatracker.ietf.org/doc/rfc1321/).
var HashAlgorithm_Md5 = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/md5"}

// [MD6 hash function](https://people.csail.mit.edu/rivest/pubs/RABCx08.pdf)
var HashAlgorithm_Md6 = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/md6"}

// any hashing algorithm that does not exist in this list of entries
var HashAlgorithm_Other = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/other"}

// SHA-1, a secure hashing algorithm, as defined in [RFC 3174](https://datatracker.ietf.org/doc/rfc3174/).
var HashAlgorithm_Sha1 = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/sha1"}

// SHA-2 with a digest length of 224, as defined in [RFC 3874](https://datatracker.ietf.org/doc/rfc3874/).
var HashAlgorithm_Sha224 = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/sha224"}

// SHA-2 with a digest length of 256, as defined in [RFC 6234](https://datatracker.ietf.org/doc/rfc6234/).
var HashAlgorithm_Sha256 = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/sha256"}

// SHA-2 with a digest length of 384, as defined in [RFC 6234](https://datatracker.ietf.org/doc/rfc6234/).
var HashAlgorithm_Sha384 = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/sha384"}

// SHA-3 with a digest length of 224, as defined in [FIPS 202](https://csrc.nist.gov/pubs/fips/202/final).
var HashAlgorithm_Sha3224 = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/sha3_224"}

// SHA-3 with a digest length of 256, as defined in [FIPS 202](https://csrc.nist.gov/pubs/fips/202/final).
var HashAlgorithm_Sha3256 = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/sha3_256"}

// SHA-3 with a digest length of 384, as defined in [FIPS 202](https://csrc.nist.gov/pubs/fips/202/final).
var HashAlgorithm_Sha3384 = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/sha3_384"}

// SHA-3 with a digest length of 512, as defined in [FIPS 202](https://csrc.nist.gov/pubs/fips/202/final).
var HashAlgorithm_Sha3512 = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/sha3_512"}

// SHA-2 with a digest length of 512, as defined in [RFC 6234](https://datatracker.ietf.org/doc/rfc6234/).
var HashAlgorithm_Sha512 = HashAlgorithm{ID: "https://spdx.org/rdf/3.0.1/terms/Core/HashAlgorithm/sha512"}

// A concrete subclass of Element used by Individuals in the
// Core profile.
type IndividualElement struct {
	Element
}

// An Individual Value for Element representing a set of Elements of unknown
// identify or cardinality (number).
var IndividualElement_NoAssertionElement = IndividualElement{Element: Element{ID: "https://spdx.org/rdf/3.0.1/terms/Core/NoAssertionElement"}}

// An Individual Value for Element representing a set of Elements with
// cardinality (number/count) of zero.
var IndividualElement_NoneElement = IndividualElement{Element: Element{ID: "https://spdx.org/rdf/3.0.1/terms/Core/NoneElement"}}

func castIndividualElement(o any) *IndividualElement {
	if o, ok := o.(AnyIndividualElement); ok {
		return o.asIndividualElement()
	}
	return nil
}

func (o *IndividualElement) asIndividualElement() *IndividualElement {
	return o
}

type AnyIndividualElement interface {
	AnyElement
	asIndividualElement() *IndividualElement
}

type IndividualElementList []AnyIndividualElement

func (o *IndividualElementList) Append(values ...AnyIndividualElement) { *o = append(*o, values...) }
func (o *IndividualElementList) Remove(value AnyIndividualElement)     { remove(o, value) }

func (o *IndividualElementList) IndividualElementIter() iter.Seq2[AnyIndividualElement, *IndividualElement] {
	return typeIter(*o, castIndividualElement)
}

// Provides an independently reproducible mechanism that permits verification of a specific Element.
type IntegrityMethod struct {
	ID string

	// Provide consumers with comments by the creator of the Element about the
	// Element.
	Comment string
}

func castIntegrityMethod(o any) *IntegrityMethod {
	if o, ok := o.(AnyIntegrityMethod); ok {
		return o.asIntegrityMethod()
	}
	return nil
}

func (o *IntegrityMethod) asIntegrityMethod() *IntegrityMethod {
	return o
}

type AnyIntegrityMethod interface {
	asIntegrityMethod() *IntegrityMethod
}

type IntegrityMethodList []AnyIntegrityMethod

func (o *IntegrityMethodList) Append(values ...AnyIntegrityMethod) { *o = append(*o, values...) }
func (o *IntegrityMethodList) Remove(value AnyIntegrityMethod)     { remove(o, value) }

func (o *IntegrityMethodList) IntegrityMethodIter() iter.Seq2[AnyIntegrityMethod, *IntegrityMethod] {
	return typeIter(*o, castIntegrityMethod)
}
func (o *IntegrityMethodList) PackageVerificationCodeIter() iter.Seq2[AnyIntegrityMethod, *PackageVerificationCode] {
	return typeIter(*o, castPackageVerificationCode)
}
func (o *IntegrityMethodList) SoftwareContentIdentifierIter() iter.Seq2[AnyIntegrityMethod, *SoftwareContentIdentifier] {
	return typeIter(*o, castSoftwareContentIdentifier)
}
func (o *IntegrityMethodList) HashIter() iter.Seq2[AnyIntegrityMethod, *Hash] {
	return typeIter(*o, castHash)
}

// Provide an enumerated set of lifecycle phases that can provide context to relationships.
type LifecycleScopeType struct {
	ID string
}

// A relationship has specific context implications during an element's build phase, during development.
var LifecycleScopeType_Build = LifecycleScopeType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/LifecycleScopeType/build"}

// A relationship has specific context implications during an element's design.
var LifecycleScopeType_Design = LifecycleScopeType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/LifecycleScopeType/design"}

// A relationship has specific context implications during development phase of an element.
var LifecycleScopeType_Development = LifecycleScopeType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/LifecycleScopeType/development"}

// A relationship has other specific context information necessary to capture that the above set of enumerations does not handle.
var LifecycleScopeType_Other = LifecycleScopeType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/LifecycleScopeType/other"}

// A relationship has specific context implications during the execution phase of an element.
var LifecycleScopeType_Runtime = LifecycleScopeType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/LifecycleScopeType/runtime"}

// A relationship has specific context implications during an element's testing phase, during development.
var LifecycleScopeType_Test = LifecycleScopeType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/LifecycleScopeType/test"}

// A mapping between prefixes and namespace partial URIs.
type NamespaceMap struct {
	ID string

	// Provides an unambiguous mechanism for conveying a URI fragment portion of an
	// Element ID.
	Namespace string
	// A substitute for a URI.
	Prefix string
}

func castNamespaceMap(o any) *NamespaceMap {
	if o, ok := o.(AnyNamespaceMap); ok {
		return o.asNamespaceMap()
	}
	return nil
}

func (o *NamespaceMap) asNamespaceMap() *NamespaceMap {
	return o
}

type AnyNamespaceMap interface {
	asNamespaceMap() *NamespaceMap
}

type NamespaceMapList []AnyNamespaceMap

func (o *NamespaceMapList) Append(values ...AnyNamespaceMap) { *o = append(*o, values...) }
func (o *NamespaceMapList) Remove(value AnyNamespaceMap)     { remove(o, value) }

func (o *NamespaceMapList) NamespaceMapIter() iter.Seq2[AnyNamespaceMap, *NamespaceMap] {
	return typeIter(*o, castNamespaceMap)
}

// An SPDX version 2.X compatible verification method for software packages.
type PackageVerificationCode struct {
	IntegrityMethod

	// Specifies the algorithm used for calculating the hash value.
	Algorithm HashAlgorithm
	// The result of applying a hash algorithm to an Element.
	HashValue string
	// The relative file name of a file to be excluded from the
	// `PackageVerificationCode`.
	PackageVerificationCodeExcludedFiles []string
}

func castPackageVerificationCode(o any) *PackageVerificationCode {
	if o, ok := o.(AnyPackageVerificationCode); ok {
		return o.asPackageVerificationCode()
	}
	return nil
}

func (o *PackageVerificationCode) asPackageVerificationCode() *PackageVerificationCode {
	return o
}

type AnyPackageVerificationCode interface {
	AnyIntegrityMethod
	asPackageVerificationCode() *PackageVerificationCode
}

type PackageVerificationCodeList []AnyPackageVerificationCode

func (o *PackageVerificationCodeList) Append(values ...AnyPackageVerificationCode) {
	*o = append(*o, values...)
}
func (o *PackageVerificationCodeList) Remove(value AnyPackageVerificationCode) { remove(o, value) }

func (o *PackageVerificationCodeList) PackageVerificationCodeIter() iter.Seq2[AnyPackageVerificationCode, *PackageVerificationCode] {
	return typeIter(*o, castPackageVerificationCode)
}

// A tuple of two positive integers that define a range.
type PositiveIntegerRange struct {
	ID string

	// Defines the beginning of a range.
	BeginIntegerRange int
	// Defines the end of a range.
	EndIntegerRange int
}

func castPositiveIntegerRange(o any) *PositiveIntegerRange {
	if o, ok := o.(AnyPositiveIntegerRange); ok {
		return o.asPositiveIntegerRange()
	}
	return nil
}

func (o *PositiveIntegerRange) asPositiveIntegerRange() *PositiveIntegerRange {
	return o
}

type AnyPositiveIntegerRange interface {
	asPositiveIntegerRange() *PositiveIntegerRange
}

type PositiveIntegerRangeList []AnyPositiveIntegerRange

func (o *PositiveIntegerRangeList) Append(values ...AnyPositiveIntegerRange) {
	*o = append(*o, values...)
}
func (o *PositiveIntegerRangeList) Remove(value AnyPositiveIntegerRange) { remove(o, value) }

func (o *PositiveIntegerRangeList) PositiveIntegerRangeIter() iter.Seq2[AnyPositiveIntegerRange, *PositiveIntegerRange] {
	return typeIter(*o, castPositiveIntegerRange)
}

// Categories of presence or absence.
type PresenceType struct {
	ID string
}

// Indicates absence of the field.
var PresenceType_No = PresenceType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/PresenceType/no"}

// Makes no assertion about the field.
var PresenceType_NoAssertion = PresenceType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/PresenceType/noAssertion"}

// Indicates presence of the field.
var PresenceType_Yes = PresenceType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/PresenceType/yes"}

// Enumeration of the valid profiles.
type ProfileIdentifierType struct {
	ID string
}

// the element follows the AI profile specification
var ProfileIdentifierType_Ai = ProfileIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ProfileIdentifierType/ai"}

// the element follows the Build profile specification
var ProfileIdentifierType_Build = ProfileIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ProfileIdentifierType/build"}

// the element follows the Core profile specification
var ProfileIdentifierType_Core = ProfileIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ProfileIdentifierType/core"}

// the element follows the Dataset profile specification
var ProfileIdentifierType_Dataset = ProfileIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ProfileIdentifierType/dataset"}

// the element follows the ExpandedLicensing profile specification
var ProfileIdentifierType_ExpandedLicensing = ProfileIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ProfileIdentifierType/expandedLicensing"}

// the element follows the Extension profile specification
var ProfileIdentifierType_Extension = ProfileIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ProfileIdentifierType/extension"}

// the element follows the Lite profile specification
var ProfileIdentifierType_Lite = ProfileIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ProfileIdentifierType/lite"}

// the element follows the Security profile specification
var ProfileIdentifierType_Security = ProfileIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ProfileIdentifierType/security"}

// the element follows the SimpleLicensing profile specification
var ProfileIdentifierType_SimpleLicensing = ProfileIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ProfileIdentifierType/simpleLicensing"}

// the element follows the Software profile specification
var ProfileIdentifierType_Software = ProfileIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/ProfileIdentifierType/software"}

// Describes a relationship between one or more elements.
type Relationship struct {
	Element

	// Provides information about the completeness of relationships.
	Completeness RelationshipCompleteness
	// Specifies the time from which an element is no longer applicable / valid.
	EndTime time.Time
	// References the Element on the left-hand side of a relationship.
	From AnyElement

	// Information about the relationship between two Elements.
	RelationshipType RelationshipType
	// Specifies the time from which an element is applicable / valid.
	StartTime time.Time
	// References an Element on the right-hand side of a relationship.
	Tos ElementList
}

func castRelationship(o any) *Relationship {
	if o, ok := o.(AnyRelationship); ok {
		return o.asRelationship()
	}
	return nil
}

func (o *Relationship) asRelationship() *Relationship {
	return o
}

type AnyRelationship interface {
	AnyElement
	asRelationship() *Relationship
}

type RelationshipList []AnyRelationship

func (o *RelationshipList) Append(values ...AnyRelationship) { *o = append(*o, values...) }
func (o *RelationshipList) Remove(value AnyRelationship)     { remove(o, value) }

func (o *RelationshipList) RelationshipIter() iter.Seq2[AnyRelationship, *Relationship] {
	return typeIter(*o, castRelationship)
}
func (o *RelationshipList) SecurityVulnAssessmentRelationshipIter() iter.Seq2[AnyRelationship, *SecurityVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVulnAssessmentRelationship)
}
func (o *RelationshipList) LifecycleScopedRelationshipIter() iter.Seq2[AnyRelationship, *LifecycleScopedRelationship] {
	return typeIter(*o, castLifecycleScopedRelationship)
}
func (o *RelationshipList) SecurityCvssV2VulnAssessmentRelationshipIter() iter.Seq2[AnyRelationship, *SecurityCvssV2VulnAssessmentRelationship] {
	return typeIter(*o, castSecurityCvssV2VulnAssessmentRelationship)
}
func (o *RelationshipList) SecurityCvssV3VulnAssessmentRelationshipIter() iter.Seq2[AnyRelationship, *SecurityCvssV3VulnAssessmentRelationship] {
	return typeIter(*o, castSecurityCvssV3VulnAssessmentRelationship)
}
func (o *RelationshipList) SecurityCvssV4VulnAssessmentRelationshipIter() iter.Seq2[AnyRelationship, *SecurityCvssV4VulnAssessmentRelationship] {
	return typeIter(*o, castSecurityCvssV4VulnAssessmentRelationship)
}
func (o *RelationshipList) SecurityEpssVulnAssessmentRelationshipIter() iter.Seq2[AnyRelationship, *SecurityEpssVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityEpssVulnAssessmentRelationship)
}
func (o *RelationshipList) SecurityExploitCatalogVulnAssessmentRelationshipIter() iter.Seq2[AnyRelationship, *SecurityExploitCatalogVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityExploitCatalogVulnAssessmentRelationship)
}
func (o *RelationshipList) SecuritySsvcVulnAssessmentRelationshipIter() iter.Seq2[AnyRelationship, *SecuritySsvcVulnAssessmentRelationship] {
	return typeIter(*o, castSecuritySsvcVulnAssessmentRelationship)
}
func (o *RelationshipList) SecurityVexVulnAssessmentRelationshipIter() iter.Seq2[AnyRelationship, *SecurityVexVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexVulnAssessmentRelationship)
}
func (o *RelationshipList) SecurityVexAffectedVulnAssessmentRelationshipIter() iter.Seq2[AnyRelationship, *SecurityVexAffectedVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexAffectedVulnAssessmentRelationship)
}
func (o *RelationshipList) SecurityVexFixedVulnAssessmentRelationshipIter() iter.Seq2[AnyRelationship, *SecurityVexFixedVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexFixedVulnAssessmentRelationship)
}
func (o *RelationshipList) SecurityVexNotAffectedVulnAssessmentRelationshipIter() iter.Seq2[AnyRelationship, *SecurityVexNotAffectedVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexNotAffectedVulnAssessmentRelationship)
}
func (o *RelationshipList) SecurityVexUnderInvestigationVulnAssessmentRelationshipIter() iter.Seq2[AnyRelationship, *SecurityVexUnderInvestigationVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexUnderInvestigationVulnAssessmentRelationship)
}

// Indicates whether a relationship is known to be complete, incomplete, or if no assertion is made with respect to relationship completeness.
type RelationshipCompleteness struct {
	ID string
}

// The relationship is known to be exhaustive.
var RelationshipCompleteness_Complete = RelationshipCompleteness{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipCompleteness/complete"}

// The relationship is known not to be exhaustive.
var RelationshipCompleteness_Incomplete = RelationshipCompleteness{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipCompleteness/incomplete"}

// No assertion can be made about the completeness of the relationship.
var RelationshipCompleteness_NoAssertion = RelationshipCompleteness{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipCompleteness/noAssertion"}

// Information about the relationship between two Elements.
type RelationshipType struct {
	ID string
}

// The `from` Vulnerability affects each `to` Element. The use of the `affects` type is constrained to `VexAffectedVulnAssessmentRelationship` classed relationships.
var RelationshipType_Affects = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/affects"}

// The `from` Element is amended by each `to` Element.
var RelationshipType_AmendedBy = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/amendedBy"}

// The `from` Element is an ancestor of each `to` Element.
var RelationshipType_AncestorOf = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/ancestorOf"}

// The `from` Element is available from the additional supplier described by each `to` Element.
var RelationshipType_AvailableFrom = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/availableFrom"}

// The `from` Element is a configuration applied to each `to` Element, during a LifecycleScopeType period.
var RelationshipType_Configures = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/configures"}

// The `from` Element contains each `to` Element.
var RelationshipType_Contains = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/contains"}

// The `from` Vulnerability is coordinatedBy the `to` Agent(s) (vendor, researcher, or consumer agent).
var RelationshipType_CoordinatedBy = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/coordinatedBy"}

// The `from` Element has been copied to each `to` Element.
var RelationshipType_CopiedTo = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/copiedTo"}

// The `from` Agent is delegating an action to the Agent of the `to` Relationship (which must be of type invokedBy), during a LifecycleScopeType (e.g. the `to` invokedBy Relationship is being done on behalf of `from`).
var RelationshipType_DelegatedTo = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/delegatedTo"}

// The `from` Element depends on each `to` Element, during a LifecycleScopeType period.
var RelationshipType_DependsOn = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/dependsOn"}

// The `from` Element is a descendant of each `to` Element.
var RelationshipType_DescendantOf = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/descendantOf"}

// The `from` Element describes each `to` Element. To denote the root(s) of a tree of elements in a collection, the rootElement property should be used.
var RelationshipType_Describes = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/describes"}

// The `from` Vulnerability has no impact on each `to` Element. The use of the `doesNotAffect` is constrained to `VexNotAffectedVulnAssessmentRelationship` classed relationships.
var RelationshipType_DoesNotAffect = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/doesNotAffect"}

// The `from` archive expands out as an artifact described by each `to` Element.
var RelationshipType_ExpandsTo = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/expandsTo"}

// The `from` Vulnerability has had an exploit created against it by each `to` Agent.
var RelationshipType_ExploitCreatedBy = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/exploitCreatedBy"}

// Designates a `from` Vulnerability has been fixed by the `to` Agent(s).
var RelationshipType_FixedBy = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/fixedBy"}

// A `from` Vulnerability has been fixed in each `to` Element. The use of the `fixedIn` type is constrained to `VexFixedVulnAssessmentRelationship` classed relationships.
var RelationshipType_FixedIn = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/fixedIn"}

// Designates a `from` Vulnerability was originally discovered by the `to` Agent(s).
var RelationshipType_FoundBy = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/foundBy"}

// The `from` Element generates each `to` Element.
var RelationshipType_Generates = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/generates"}

// Every `to` Element is a file added to the `from` Element (`from` hasAddedFile `to`).
var RelationshipType_HasAddedFile = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasAddedFile"}

// Relates a `from` Vulnerability and each `to` Element with a security assessment. To be used with `VulnAssessmentRelationship` types.
var RelationshipType_HasAssessmentFor = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasAssessmentFor"}

// Used to associate a `from` Artifact with each `to` Vulnerability.
var RelationshipType_HasAssociatedVulnerability = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasAssociatedVulnerability"}

// The `from` SoftwareArtifact is concluded by the SPDX data creator to be governed by each `to` license.
var RelationshipType_HasConcludedLicense = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasConcludedLicense"}

// The `from` Element treats each `to` Element as a data file. A data file is an artifact that stores data required or optional for the `from` Element's functionality. A data file can be a database file, an index file, a log file, an AI model file, a calibration data file, a temporary file, a backup file, and more. For AI training dataset, test dataset, test artifact, configuration data, build input data, and build output data, please consider using the more specific relationship types: `trainedOn`, `testedOn`, `hasTest`, `configures`, `hasInput`, and `hasOutput`, respectively. This relationship does not imply dependency.
var RelationshipType_HasDataFile = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasDataFile"}

// The `from` SoftwareArtifact was discovered to actually contain each `to` license, for example as detected by use of automated tooling.
var RelationshipType_HasDeclaredLicense = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasDeclaredLicense"}

// Every `to` Element is a file deleted from the `from` Element (`from` hasDeletedFile `to`).
var RelationshipType_HasDeletedFile = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasDeletedFile"}

// The `from` Element has manifest files that contain dependency information in each `to` Element.
var RelationshipType_HasDependencyManifest = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasDependencyManifest"}

// The `from` Element is distributed as an artifact in each `to` Element (e.g. an RPM or archive file).
var RelationshipType_HasDistributionArtifact = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasDistributionArtifact"}

// The `from` Element is documented by each `to` Element.
var RelationshipType_HasDocumentation = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasDocumentation"}

// The `from` Element dynamically links in each `to` Element, during a LifecycleScopeType period.
var RelationshipType_HasDynamicLink = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasDynamicLink"}

// Every `to` Element is considered as evidence for the `from` Element (`from` hasEvidence `to`).
var RelationshipType_HasEvidence = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasEvidence"}

// Every `to` Element is an example for the `from` Element (`from` hasExample `to`).
var RelationshipType_HasExample = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasExample"}

// The `from` Build was run on the `to` Element during a LifecycleScopeType period (e.g. the host that the build runs on).
var RelationshipType_HasHost = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasHost"}

// The `from` Build has each `to` Element as an input, during a LifecycleScopeType period.
var RelationshipType_HasInput = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasInput"}

// Every `to` Element is metadata about the `from` Element (`from` hasMetadata `to`).
var RelationshipType_HasMetadata = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasMetadata"}

// Every `to` Element is an optional component of the `from` Element (`from` hasOptionalComponent `to`).
var RelationshipType_HasOptionalComponent = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasOptionalComponent"}

// The `from` Element optionally depends on each `to` Element, during a LifecycleScopeType period.
var RelationshipType_HasOptionalDependency = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasOptionalDependency"}

// The `from` Build element generates each `to` Element as an output, during a LifecycleScopeType period.
var RelationshipType_HasOutput = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasOutput"}

// The `from` Element has a prerequisite on each `to` Element, during a LifecycleScopeType period.
var RelationshipType_HasPrerequisite = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasPrerequisite"}

// The `from` Element has a dependency on each `to` Element, dependency is not in the distributed artifact, but assumed to be provided, during a LifecycleScopeType period.
var RelationshipType_HasProvidedDependency = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasProvidedDependency"}

// The `from` Element has a requirement on each `to` Element, during a LifecycleScopeType period.
var RelationshipType_HasRequirement = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasRequirement"}

// Every `to` Element is a specification for the `from` Element (`from` hasSpecification `to`), during a LifecycleScopeType period.
var RelationshipType_HasSpecification = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasSpecification"}

// The `from` Element statically links in each `to` Element, during a LifecycleScopeType period.
var RelationshipType_HasStaticLink = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasStaticLink"}

// Every `to` Element is a test artifact for the `from` Element (`from` hasTest `to`), during a LifecycleScopeType period.
var RelationshipType_HasTest = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasTest"}

// Every `to` Element is a test case for the `from` Element (`from` hasTestCase `to`).
var RelationshipType_HasTestCase = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasTestCase"}

// Every `to` Element is a variant the `from` Element (`from` hasVariant `to`).
var RelationshipType_HasVariant = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/hasVariant"}

// The `from` Element was invoked by the `to` Agent, during a LifecycleScopeType period (for example, a Build element that describes a build step).
var RelationshipType_InvokedBy = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/invokedBy"}

// The `from` Element is modified by each `to` Element.
var RelationshipType_ModifiedBy = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/modifiedBy"}

// Every `to` Element is related to the `from` Element where the relationship type is not described by any of the SPDX relationship types (this relationship is directionless).
var RelationshipType_Other = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/other"}

// Every `to` Element is a packaged instance of the `from` Element (`from` packagedBy `to`).
var RelationshipType_PackagedBy = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/packagedBy"}

// Every `to` Element is a patch for the `from` Element (`from` patchedBy `to`).
var RelationshipType_PatchedBy = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/patchedBy"}

// Designates a `from` Vulnerability was made available for public use or reference by each `to` Agent.
var RelationshipType_PublishedBy = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/publishedBy"}

// Designates a `from` Vulnerability was first reported to a project, vendor, or tracking database for formal identification by each `to` Agent.
var RelationshipType_ReportedBy = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/reportedBy"}

// Designates a `from` Vulnerability's details were tracked, aggregated, and/or enriched to improve context (i.e. NVD) by each `to` Agent.
var RelationshipType_RepublishedBy = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/republishedBy"}

// The `from` SpdxDocument can be found in a serialized form in each `to` Artifact.
var RelationshipType_SerializedInArtifact = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/serializedInArtifact"}

// The `from` Element has been tested on the `to` Element(s).
var RelationshipType_TestedOn = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/testedOn"}

// The `from` Element has been trained on the `to` Element(s).
var RelationshipType_TrainedOn = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/trainedOn"}

// The `from` Vulnerability impact is being investigated for each `to` Element. The use of the `underInvestigationFor` type is constrained to `VexUnderInvestigationVulnAssessmentRelationship` classed relationships.
var RelationshipType_UnderInvestigationFor = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/underInvestigationFor"}

// The `from` Element uses each `to` Element as a tool, during a LifecycleScopeType period.
var RelationshipType_UsesTool = RelationshipType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/RelationshipType/usesTool"}

// A collection of SPDX Elements that could potentially be serialized.
type SpdxDocument struct {
	ElementCollection

	// Provides the license under which the SPDX documentation of the Element can be
	// used.
	DataLicense AnySimplelicensingAnyLicenseInfo

	// Provides an ExternalMap of Element identifiers.
	Imports ExternalMapList

	// Provides a NamespaceMap of prefixes and associated namespace partial URIs applicable to an SpdxDocument and independent of any specific serialization format or instance.
	NamespaceMaps NamespaceMapList
}

func castSpdxDocument(o any) *SpdxDocument {
	if o, ok := o.(AnySpdxDocument); ok {
		return o.asSpdxDocument()
	}
	return nil
}

func (o *SpdxDocument) asSpdxDocument() *SpdxDocument {
	return o
}

type AnySpdxDocument interface {
	AnyElementCollection
	asSpdxDocument() *SpdxDocument
}

type SpdxDocumentList []AnySpdxDocument

func (o *SpdxDocumentList) Append(values ...AnySpdxDocument) { *o = append(*o, values...) }
func (o *SpdxDocumentList) Remove(value AnySpdxDocument)     { remove(o, value) }

func (o *SpdxDocumentList) SpdxDocumentIter() iter.Seq2[AnySpdxDocument, *SpdxDocument] {
	return typeIter(*o, castSpdxDocument)
}

// Indicates the type of support that is associated with an artifact.
type SupportType struct {
	ID string
}

// in addition to being supported by the supplier, the software is known to have been deployed and is in use.  For a software as a service provider, this implies the software is now available as a service.
var SupportType_Deployed = SupportType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/SupportType/deployed"}

// the artifact is in active development and is not considered ready for formal support from the supplier.
var SupportType_Development = SupportType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/SupportType/development"}

// there is a defined end of support for the artifact from the supplier.  This may also be referred to as end of life. There is a validUntilDate that can be used to signal when support ends for the artifact.
var SupportType_EndOfSupport = SupportType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/SupportType/endOfSupport"}

// the artifact has been released, and there is limited support available from the supplier. There is a validUntilDate that can provide additional information about the duration of support.
var SupportType_LimitedSupport = SupportType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/SupportType/limitedSupport"}

// no assertion about the type of support is made.   This is considered the default if no other support type is used.
var SupportType_NoAssertion = SupportType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/SupportType/noAssertion"}

// there is no support for the artifact from the supplier, consumer assumes any support obligations.
var SupportType_NoSupport = SupportType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/SupportType/noSupport"}

// the artifact has been released, and is supported from the supplier.   There is a validUntilDate that can provide additional information about the duration of support.
var SupportType_Support = SupportType{ID: "https://spdx.org/rdf/3.0.1/terms/Core/SupportType/support"}

// An element of hardware and/or software utilized to carry out a particular function.
type Tool struct {
	Element
}

func castTool(o any) *Tool {
	if o, ok := o.(AnyTool); ok {
		return o.asTool()
	}
	return nil
}

func (o *Tool) asTool() *Tool {
	return o
}

type AnyTool interface {
	AnyElement
	asTool() *Tool
}

type ToolList []AnyTool

func (o *ToolList) Append(values ...AnyTool) { *o = append(*o, values...) }
func (o *ToolList) Remove(value AnyTool)     { remove(o, value) }

func (o *ToolList) ToolIter() iter.Seq2[AnyTool, *Tool] { return typeIter(*o, castTool) }

// Categories of confidentiality level.
type DatasetConfidentialityLevelType struct {
	ID string
}

// Data points in the dataset can be shared only with specific organizations and their clients on a need to know basis.
var DatasetConfidentialityLevelType_Amber = DatasetConfidentialityLevelType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/ConfidentialityLevelType/amber"}

// Dataset may be distributed freely, without restriction.
var DatasetConfidentialityLevelType_Clear = DatasetConfidentialityLevelType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/ConfidentialityLevelType/clear"}

// Dataset can be shared within a community of peers and partners.
var DatasetConfidentialityLevelType_Green = DatasetConfidentialityLevelType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/ConfidentialityLevelType/green"}

// Data points in the dataset are highly confidential and can only be shared with named recipients.
var DatasetConfidentialityLevelType_Red = DatasetConfidentialityLevelType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/ConfidentialityLevelType/red"}

// Availability of dataset.
type DatasetDatasetAvailabilityType struct {
	ID string
}

// the dataset is not publicly available and can only be accessed after affirmatively accepting terms on a clickthrough webpage.
var DatasetDatasetAvailabilityType_Clickthrough = DatasetDatasetAvailabilityType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/DatasetAvailabilityType/clickthrough"}

// the dataset is publicly available and can be downloaded directly.
var DatasetDatasetAvailabilityType_DirectDownload = DatasetDatasetAvailabilityType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/DatasetAvailabilityType/directDownload"}

// the dataset is publicly available, but not all at once, and can only be accessed through queries which return parts of the dataset.
var DatasetDatasetAvailabilityType_Query = DatasetDatasetAvailabilityType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/DatasetAvailabilityType/query"}

// the dataset is not publicly available and an email registration is required before accessing the dataset, although without an affirmative acceptance of terms.
var DatasetDatasetAvailabilityType_Registration = DatasetDatasetAvailabilityType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/DatasetAvailabilityType/registration"}

// the dataset provider is not making available the underlying data and the dataset must be reassembled, typically using the provided script for scraping the data.
var DatasetDatasetAvailabilityType_ScrapingScript = DatasetDatasetAvailabilityType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/DatasetAvailabilityType/scrapingScript"}

// Enumeration of dataset types.
type DatasetDatasetType struct {
	ID string
}

// data is audio based, such as a collection of music from the 80s.
var DatasetDatasetType_Audio = DatasetDatasetType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/DatasetType/audio"}

// data that is classified into a discrete number of categories, such as the eye color of a population of people.
var DatasetDatasetType_Categorical = DatasetDatasetType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/DatasetType/categorical"}

// data is in the form of a graph where entries are somehow related to each other through edges, such a social network of friends.
var DatasetDatasetType_Graph = DatasetDatasetType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/DatasetType/graph"}

// data is a collection of images such as pictures of animals.
var DatasetDatasetType_Image = DatasetDatasetType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/DatasetType/image"}

// data type is not known.
var DatasetDatasetType_NoAssertion = DatasetDatasetType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/DatasetType/noAssertion"}

// data consists only of numeric entries.
var DatasetDatasetType_Numeric = DatasetDatasetType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/DatasetType/numeric"}

// data is of a type not included in this list.
var DatasetDatasetType_Other = DatasetDatasetType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/DatasetType/other"}

// data is recorded from a physical sensor, such as a thermometer reading or biometric device.
var DatasetDatasetType_Sensor = DatasetDatasetType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/DatasetType/sensor"}

// data is stored in tabular format or retrieved from a relational database.
var DatasetDatasetType_Structured = DatasetDatasetType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/DatasetType/structured"}

// data describes the syntax or semantics of a language or text, such as a parse tree used for natural language processing.
var DatasetDatasetType_Syntactic = DatasetDatasetType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/DatasetType/syntactic"}

// data consists of unstructured text, such as a book, Wikipedia article (without images), or transcript.
var DatasetDatasetType_Text = DatasetDatasetType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/DatasetType/text"}

// data is recorded in an ordered sequence of timestamped entries, such as the price of a stock over the course of a day.
var DatasetDatasetType_Timeseries = DatasetDatasetType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/DatasetType/timeseries"}

// data is recorded with a timestamp for each entry, but not necessarily ordered or at specific intervals, such as when a taxi ride starts and ends.
var DatasetDatasetType_Timestamp = DatasetDatasetType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/DatasetType/timestamp"}

// data is video based, such as a collection of movie clips featuring Tom Hanks.
var DatasetDatasetType_Video = DatasetDatasetType{ID: "https://spdx.org/rdf/3.0.1/terms/Dataset/DatasetType/video"}

// Abstract class for additional text intended to be added to a License, but
// which is not itself a standalone License.
type ExpandedlicensingLicenseAddition struct {
	Element

	// Identifies the full text of a LicenseAddition.
	ExpandedlicensingAdditionText string
	// Specifies whether an additional text identifier has been marked as deprecated.
	ExpandedlicensingIsDeprecatedAdditionId bool
	// Identifies all the text and metadata associated with a license in the license
	// XML format.
	ExpandedlicensingLicenseXml string
	// Specifies the licenseId that is preferred to be used in place of a deprecated
	// License or LicenseAddition.
	ExpandedlicensingObsoletedBy string
	// Contains a URL where the License or LicenseAddition can be found in use.
	ExpandedlicensingSeeAlsos []string
	// Identifies the full text of a LicenseAddition, in SPDX templating format.
	ExpandedlicensingStandardAdditionTemplate string
}

func castExpandedlicensingLicenseAddition(o any) *ExpandedlicensingLicenseAddition {
	if o, ok := o.(AnyExpandedlicensingLicenseAddition); ok {
		return o.asExpandedlicensingLicenseAddition()
	}
	return nil
}

func (o *ExpandedlicensingLicenseAddition) asExpandedlicensingLicenseAddition() *ExpandedlicensingLicenseAddition {
	return o
}

type AnyExpandedlicensingLicenseAddition interface {
	AnyElement
	asExpandedlicensingLicenseAddition() *ExpandedlicensingLicenseAddition
}

type ExpandedlicensingLicenseAdditionList []AnyExpandedlicensingLicenseAddition

func (o *ExpandedlicensingLicenseAdditionList) Append(values ...AnyExpandedlicensingLicenseAddition) {
	*o = append(*o, values...)
}
func (o *ExpandedlicensingLicenseAdditionList) Remove(value AnyExpandedlicensingLicenseAddition) {
	remove(o, value)
}

func (o *ExpandedlicensingLicenseAdditionList) ExpandedlicensingLicenseAdditionIter() iter.Seq2[AnyExpandedlicensingLicenseAddition, *ExpandedlicensingLicenseAddition] {
	return typeIter(*o, castExpandedlicensingLicenseAddition)
}
func (o *ExpandedlicensingLicenseAdditionList) ExpandedlicensingListedLicenseExceptionIter() iter.Seq2[AnyExpandedlicensingLicenseAddition, *ExpandedlicensingListedLicenseException] {
	return typeIter(*o, castExpandedlicensingListedLicenseException)
}
func (o *ExpandedlicensingLicenseAdditionList) ExpandedlicensingCustomLicenseAdditionIter() iter.Seq2[AnyExpandedlicensingLicenseAddition, *ExpandedlicensingCustomLicenseAddition] {
	return typeIter(*o, castExpandedlicensingCustomLicenseAddition)
}

// A license exception that is listed on the SPDX Exceptions list.
type ExpandedlicensingListedLicenseException struct {
	ExpandedlicensingLicenseAddition

	// Specifies the SPDX License List version in which this license or exception
	// identifier was deprecated.
	ExpandedlicensingDeprecatedVersion string
	// Specifies the SPDX License List version in which this ListedLicense or
	// ListedLicenseException identifier was first added.
	ExpandedlicensingListVersionAdded string
}

func castExpandedlicensingListedLicenseException(o any) *ExpandedlicensingListedLicenseException {
	if o, ok := o.(AnyExpandedlicensingListedLicenseException); ok {
		return o.asExpandedlicensingListedLicenseException()
	}
	return nil
}

func (o *ExpandedlicensingListedLicenseException) asExpandedlicensingListedLicenseException() *ExpandedlicensingListedLicenseException {
	return o
}

type AnyExpandedlicensingListedLicenseException interface {
	AnyExpandedlicensingLicenseAddition
	asExpandedlicensingListedLicenseException() *ExpandedlicensingListedLicenseException
}

type ExpandedlicensingListedLicenseExceptionList []AnyExpandedlicensingListedLicenseException

func (o *ExpandedlicensingListedLicenseExceptionList) Append(values ...AnyExpandedlicensingListedLicenseException) {
	*o = append(*o, values...)
}
func (o *ExpandedlicensingListedLicenseExceptionList) Remove(value AnyExpandedlicensingListedLicenseException) {
	remove(o, value)
}

func (o *ExpandedlicensingListedLicenseExceptionList) ExpandedlicensingListedLicenseExceptionIter() iter.Seq2[AnyExpandedlicensingListedLicenseException, *ExpandedlicensingListedLicenseException] {
	return typeIter(*o, castExpandedlicensingListedLicenseException)
}

// A property name with an associated value.
type ExtensionCdxPropertyEntry struct {
	ID string

	// A name used in a CdxPropertyEntry name-value pair.
	ExtensionCdxPropName string
	// A value used in a CdxPropertyEntry name-value pair.
	ExtensionCdxPropValue string
}

func castExtensionCdxPropertyEntry(o any) *ExtensionCdxPropertyEntry {
	if o, ok := o.(AnyExtensionCdxPropertyEntry); ok {
		return o.asExtensionCdxPropertyEntry()
	}
	return nil
}

func (o *ExtensionCdxPropertyEntry) asExtensionCdxPropertyEntry() *ExtensionCdxPropertyEntry {
	return o
}

type AnyExtensionCdxPropertyEntry interface {
	asExtensionCdxPropertyEntry() *ExtensionCdxPropertyEntry
}

type ExtensionCdxPropertyEntryList []AnyExtensionCdxPropertyEntry

func (o *ExtensionCdxPropertyEntryList) Append(values ...AnyExtensionCdxPropertyEntry) {
	*o = append(*o, values...)
}
func (o *ExtensionCdxPropertyEntryList) Remove(value AnyExtensionCdxPropertyEntry) { remove(o, value) }

func (o *ExtensionCdxPropertyEntryList) ExtensionCdxPropertyEntryIter() iter.Seq2[AnyExtensionCdxPropertyEntry, *ExtensionCdxPropertyEntry] {
	return typeIter(*o, castExtensionCdxPropertyEntry)
}

// A characterization of some aspect of an Element that is associated with the Element in a generalized fashion.
type ExtensionExtension struct {
	ID string
}

func castExtensionExtension(o any) *ExtensionExtension {
	if o, ok := o.(AnyExtensionExtension); ok {
		return o.asExtensionExtension()
	}
	return nil
}

func (o *ExtensionExtension) asExtensionExtension() *ExtensionExtension {
	return o
}

type AnyExtensionExtension interface {
	asExtensionExtension() *ExtensionExtension
}

type ExtensionExtensionList []AnyExtensionExtension

func (o *ExtensionExtensionList) Append(values ...AnyExtensionExtension) { *o = append(*o, values...) }
func (o *ExtensionExtensionList) Remove(value AnyExtensionExtension)     { remove(o, value) }

func (o *ExtensionExtensionList) ExtensionExtensionIter() iter.Seq2[AnyExtensionExtension, *ExtensionExtension] {
	return typeIter(*o, castExtensionExtension)
}
func (o *ExtensionExtensionList) ExtensionCdxPropertiesExtensionIter() iter.Seq2[AnyExtensionExtension, *ExtensionCdxPropertiesExtension] {
	return typeIter(*o, castExtensionCdxPropertiesExtension)
}

// Specifies the CVSS base, temporal, threat, or environmental severity type.
type SecurityCvssSeverityType struct {
	ID string
}

// When a CVSS score is between 9.0 - 10.0
var SecurityCvssSeverityType_Critical = SecurityCvssSeverityType{ID: "https://spdx.org/rdf/3.0.1/terms/Security/CvssSeverityType/critical"}

// When a CVSS score is between 7.0 - 8.9
var SecurityCvssSeverityType_High = SecurityCvssSeverityType{ID: "https://spdx.org/rdf/3.0.1/terms/Security/CvssSeverityType/high"}

// When a CVSS score is between 0.1 - 3.9
var SecurityCvssSeverityType_Low = SecurityCvssSeverityType{ID: "https://spdx.org/rdf/3.0.1/terms/Security/CvssSeverityType/low"}

// When a CVSS score is between 4.0 - 6.9
var SecurityCvssSeverityType_Medium = SecurityCvssSeverityType{ID: "https://spdx.org/rdf/3.0.1/terms/Security/CvssSeverityType/medium"}

// When a CVSS score is 0.0
var SecurityCvssSeverityType_None = SecurityCvssSeverityType{ID: "https://spdx.org/rdf/3.0.1/terms/Security/CvssSeverityType/none"}

// Specifies the exploit catalog type.
type SecurityExploitCatalogType struct {
	ID string
}

// CISA's Known Exploited Vulnerability (KEV) Catalog
var SecurityExploitCatalogType_Kev = SecurityExploitCatalogType{ID: "https://spdx.org/rdf/3.0.1/terms/Security/ExploitCatalogType/kev"}

// Other exploit catalogs
var SecurityExploitCatalogType_Other = SecurityExploitCatalogType{ID: "https://spdx.org/rdf/3.0.1/terms/Security/ExploitCatalogType/other"}

// Specifies the SSVC decision type.
type SecuritySsvcDecisionType struct {
	ID string
}

// The vulnerability requires attention from the organization's internal, supervisory-level and leadership-level individuals. Necessary actions include requesting assistance or information about the vulnerability, as well as publishing a notification either internally and/or externally. Typically, internal groups would meet to determine the overall response and then execute agreed upon actions. CISA recommends remediating Act vulnerabilities as soon as possible.
var SecuritySsvcDecisionType_Act = SecuritySsvcDecisionType{ID: "https://spdx.org/rdf/3.0.1/terms/Security/SsvcDecisionType/act"}

// The vulnerability requires attention from the organization's internal, supervisory-level individuals. Necessary actions include requesting assistance or information about the vulnerability, and may involve publishing a notification either internally and/or externally. CISA recommends remediating Attend vulnerabilities sooner than standard update timelines.
var SecuritySsvcDecisionType_Attend = SecuritySsvcDecisionType{ID: "https://spdx.org/rdf/3.0.1/terms/Security/SsvcDecisionType/attend"}

// The vulnerability does not require action at this time. The organization would continue to track the vulnerability and reassess it if new information becomes available. CISA recommends remediating Track vulnerabilities within standard update timelines.
var SecuritySsvcDecisionType_Track = SecuritySsvcDecisionType{ID: "https://spdx.org/rdf/3.0.1/terms/Security/SsvcDecisionType/track"}

// ("Track\*" in the SSVC spec) The vulnerability contains specific characteristics that may require closer monitoring for changes. CISA recommends remediating Track\* vulnerabilities within standard update timelines.
var SecuritySsvcDecisionType_TrackStar = SecuritySsvcDecisionType{ID: "https://spdx.org/rdf/3.0.1/terms/Security/SsvcDecisionType/trackStar"}

// Specifies the VEX justification type.
type SecurityVexJustificationType struct {
	ID string
}

// The software is not affected because the vulnerable component is not in the product.
var SecurityVexJustificationType_ComponentNotPresent = SecurityVexJustificationType{ID: "https://spdx.org/rdf/3.0.1/terms/Security/VexJustificationType/componentNotPresent"}

// Built-in inline controls or mitigations prevent an adversary from leveraging the vulnerability.
var SecurityVexJustificationType_InlineMitigationsAlreadyExist = SecurityVexJustificationType{ID: "https://spdx.org/rdf/3.0.1/terms/Security/VexJustificationType/inlineMitigationsAlreadyExist"}

// The vulnerable component is present, and the component contains the vulnerable code. However, vulnerable code is used in such a way that an attacker cannot mount any anticipated attack.
var SecurityVexJustificationType_VulnerableCodeCannotBeControlledByAdversary = SecurityVexJustificationType{ID: "https://spdx.org/rdf/3.0.1/terms/Security/VexJustificationType/vulnerableCodeCannotBeControlledByAdversary"}

// The affected code is not reachable through the execution of the code, including non-anticipated states of the product.
var SecurityVexJustificationType_VulnerableCodeNotInExecutePath = SecurityVexJustificationType{ID: "https://spdx.org/rdf/3.0.1/terms/Security/VexJustificationType/vulnerableCodeNotInExecutePath"}

// The product is not affected because the code underlying the vulnerability is not present in the product.
var SecurityVexJustificationType_VulnerableCodeNotPresent = SecurityVexJustificationType{ID: "https://spdx.org/rdf/3.0.1/terms/Security/VexJustificationType/vulnerableCodeNotPresent"}

// Abstract ancestor class for all vulnerability assessments
type SecurityVulnAssessmentRelationship struct {
	Relationship

	// Identifies who or what supplied the artifact or VulnAssessmentRelationship
	// referenced by the Element.
	SuppliedBy AnyAgent

	// Specifies an Element contained in a piece of software where a vulnerability was
	// found.
	SecurityAssessedElement AnySoftwareSoftwareArtifact

	// Specifies a time when a vulnerability assessment was modified
	SecurityModifiedTime time.Time
	// Specifies the time when a vulnerability was published.
	SecurityPublishedTime time.Time
	// Specified the time and date when a vulnerability was withdrawn.
	SecurityWithdrawnTime time.Time
}

func castSecurityVulnAssessmentRelationship(o any) *SecurityVulnAssessmentRelationship {
	if o, ok := o.(AnySecurityVulnAssessmentRelationship); ok {
		return o.asSecurityVulnAssessmentRelationship()
	}
	return nil
}

func (o *SecurityVulnAssessmentRelationship) asSecurityVulnAssessmentRelationship() *SecurityVulnAssessmentRelationship {
	return o
}

type AnySecurityVulnAssessmentRelationship interface {
	AnyRelationship
	asSecurityVulnAssessmentRelationship() *SecurityVulnAssessmentRelationship
}

type SecurityVulnAssessmentRelationshipList []AnySecurityVulnAssessmentRelationship

func (o *SecurityVulnAssessmentRelationshipList) Append(values ...AnySecurityVulnAssessmentRelationship) {
	*o = append(*o, values...)
}
func (o *SecurityVulnAssessmentRelationshipList) Remove(value AnySecurityVulnAssessmentRelationship) {
	remove(o, value)
}

func (o *SecurityVulnAssessmentRelationshipList) SecurityVulnAssessmentRelationshipIter() iter.Seq2[AnySecurityVulnAssessmentRelationship, *SecurityVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVulnAssessmentRelationship)
}
func (o *SecurityVulnAssessmentRelationshipList) SecurityCvssV2VulnAssessmentRelationshipIter() iter.Seq2[AnySecurityVulnAssessmentRelationship, *SecurityCvssV2VulnAssessmentRelationship] {
	return typeIter(*o, castSecurityCvssV2VulnAssessmentRelationship)
}
func (o *SecurityVulnAssessmentRelationshipList) SecurityCvssV3VulnAssessmentRelationshipIter() iter.Seq2[AnySecurityVulnAssessmentRelationship, *SecurityCvssV3VulnAssessmentRelationship] {
	return typeIter(*o, castSecurityCvssV3VulnAssessmentRelationship)
}
func (o *SecurityVulnAssessmentRelationshipList) SecurityCvssV4VulnAssessmentRelationshipIter() iter.Seq2[AnySecurityVulnAssessmentRelationship, *SecurityCvssV4VulnAssessmentRelationship] {
	return typeIter(*o, castSecurityCvssV4VulnAssessmentRelationship)
}
func (o *SecurityVulnAssessmentRelationshipList) SecurityEpssVulnAssessmentRelationshipIter() iter.Seq2[AnySecurityVulnAssessmentRelationship, *SecurityEpssVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityEpssVulnAssessmentRelationship)
}
func (o *SecurityVulnAssessmentRelationshipList) SecurityExploitCatalogVulnAssessmentRelationshipIter() iter.Seq2[AnySecurityVulnAssessmentRelationship, *SecurityExploitCatalogVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityExploitCatalogVulnAssessmentRelationship)
}
func (o *SecurityVulnAssessmentRelationshipList) SecuritySsvcVulnAssessmentRelationshipIter() iter.Seq2[AnySecurityVulnAssessmentRelationship, *SecuritySsvcVulnAssessmentRelationship] {
	return typeIter(*o, castSecuritySsvcVulnAssessmentRelationship)
}
func (o *SecurityVulnAssessmentRelationshipList) SecurityVexVulnAssessmentRelationshipIter() iter.Seq2[AnySecurityVulnAssessmentRelationship, *SecurityVexVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexVulnAssessmentRelationship)
}
func (o *SecurityVulnAssessmentRelationshipList) SecurityVexAffectedVulnAssessmentRelationshipIter() iter.Seq2[AnySecurityVulnAssessmentRelationship, *SecurityVexAffectedVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexAffectedVulnAssessmentRelationship)
}
func (o *SecurityVulnAssessmentRelationshipList) SecurityVexFixedVulnAssessmentRelationshipIter() iter.Seq2[AnySecurityVulnAssessmentRelationship, *SecurityVexFixedVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexFixedVulnAssessmentRelationship)
}
func (o *SecurityVulnAssessmentRelationshipList) SecurityVexNotAffectedVulnAssessmentRelationshipIter() iter.Seq2[AnySecurityVulnAssessmentRelationship, *SecurityVexNotAffectedVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexNotAffectedVulnAssessmentRelationship)
}
func (o *SecurityVulnAssessmentRelationshipList) SecurityVexUnderInvestigationVulnAssessmentRelationshipIter() iter.Seq2[AnySecurityVulnAssessmentRelationship, *SecurityVexUnderInvestigationVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexUnderInvestigationVulnAssessmentRelationship)
}

// Abstract class representing a license combination consisting of one or more licenses.
type SimplelicensingAnyLicenseInfo struct {
	Element
}

func castSimplelicensingAnyLicenseInfo(o any) *SimplelicensingAnyLicenseInfo {
	if o, ok := o.(AnySimplelicensingAnyLicenseInfo); ok {
		return o.asSimplelicensingAnyLicenseInfo()
	}
	return nil
}

func (o *SimplelicensingAnyLicenseInfo) asSimplelicensingAnyLicenseInfo() *SimplelicensingAnyLicenseInfo {
	return o
}

type AnySimplelicensingAnyLicenseInfo interface {
	AnyElement
	asSimplelicensingAnyLicenseInfo() *SimplelicensingAnyLicenseInfo
}

type SimplelicensingAnyLicenseInfoList []AnySimplelicensingAnyLicenseInfo

func (o *SimplelicensingAnyLicenseInfoList) Append(values ...AnySimplelicensingAnyLicenseInfo) {
	*o = append(*o, values...)
}
func (o *SimplelicensingAnyLicenseInfoList) Remove(value AnySimplelicensingAnyLicenseInfo) {
	remove(o, value)
}

func (o *SimplelicensingAnyLicenseInfoList) SimplelicensingAnyLicenseInfoIter() iter.Seq2[AnySimplelicensingAnyLicenseInfo, *SimplelicensingAnyLicenseInfo] {
	return typeIter(*o, castSimplelicensingAnyLicenseInfo)
}
func (o *SimplelicensingAnyLicenseInfoList) SimplelicensingLicenseExpressionIter() iter.Seq2[AnySimplelicensingAnyLicenseInfo, *SimplelicensingLicenseExpression] {
	return typeIter(*o, castSimplelicensingLicenseExpression)
}
func (o *SimplelicensingAnyLicenseInfoList) ExpandedlicensingConjunctiveLicenseSetIter() iter.Seq2[AnySimplelicensingAnyLicenseInfo, *ExpandedlicensingConjunctiveLicenseSet] {
	return typeIter(*o, castExpandedlicensingConjunctiveLicenseSet)
}
func (o *SimplelicensingAnyLicenseInfoList) ExpandedlicensingDisjunctiveLicenseSetIter() iter.Seq2[AnySimplelicensingAnyLicenseInfo, *ExpandedlicensingDisjunctiveLicenseSet] {
	return typeIter(*o, castExpandedlicensingDisjunctiveLicenseSet)
}
func (o *SimplelicensingAnyLicenseInfoList) ExpandedlicensingExtendableLicenseIter() iter.Seq2[AnySimplelicensingAnyLicenseInfo, *ExpandedlicensingExtendableLicense] {
	return typeIter(*o, castExpandedlicensingExtendableLicense)
}
func (o *SimplelicensingAnyLicenseInfoList) ExpandedlicensingIndividualLicensingInfoIter() iter.Seq2[AnySimplelicensingAnyLicenseInfo, *ExpandedlicensingIndividualLicensingInfo] {
	return typeIter(*o, castExpandedlicensingIndividualLicensingInfo)
}
func (o *SimplelicensingAnyLicenseInfoList) ExpandedlicensingLicenseIter() iter.Seq2[AnySimplelicensingAnyLicenseInfo, *ExpandedlicensingLicense] {
	return typeIter(*o, castExpandedlicensingLicense)
}
func (o *SimplelicensingAnyLicenseInfoList) ExpandedlicensingListedLicenseIter() iter.Seq2[AnySimplelicensingAnyLicenseInfo, *ExpandedlicensingListedLicense] {
	return typeIter(*o, castExpandedlicensingListedLicense)
}
func (o *SimplelicensingAnyLicenseInfoList) ExpandedlicensingOrLaterOperatorIter() iter.Seq2[AnySimplelicensingAnyLicenseInfo, *ExpandedlicensingOrLaterOperator] {
	return typeIter(*o, castExpandedlicensingOrLaterOperator)
}
func (o *SimplelicensingAnyLicenseInfoList) ExpandedlicensingWithAdditionOperatorIter() iter.Seq2[AnySimplelicensingAnyLicenseInfo, *ExpandedlicensingWithAdditionOperator] {
	return typeIter(*o, castExpandedlicensingWithAdditionOperator)
}
func (o *SimplelicensingAnyLicenseInfoList) ExpandedlicensingCustomLicenseIter() iter.Seq2[AnySimplelicensingAnyLicenseInfo, *ExpandedlicensingCustomLicense] {
	return typeIter(*o, castExpandedlicensingCustomLicense)
}

// An SPDX Element containing an SPDX license expression string.
type SimplelicensingLicenseExpression struct {
	SimplelicensingAnyLicenseInfo

	// Maps a LicenseRef or AdditionRef string for a Custom License or a Custom
	// License Addition to its URI ID.
	SimplelicensingCustomIdToUris DictionaryEntryList

	// A string in the license expression format.
	SimplelicensingLicenseExpression string
	// The version of the SPDX License List used in the license expression.
	SimplelicensingLicenseListVersion string
}

func castSimplelicensingLicenseExpression(o any) *SimplelicensingLicenseExpression {
	if o, ok := o.(AnySimplelicensingLicenseExpression); ok {
		return o.asSimplelicensingLicenseExpression()
	}
	return nil
}

func (o *SimplelicensingLicenseExpression) asSimplelicensingLicenseExpression() *SimplelicensingLicenseExpression {
	return o
}

type AnySimplelicensingLicenseExpression interface {
	AnySimplelicensingAnyLicenseInfo
	asSimplelicensingLicenseExpression() *SimplelicensingLicenseExpression
}

type SimplelicensingLicenseExpressionList []AnySimplelicensingLicenseExpression

func (o *SimplelicensingLicenseExpressionList) Append(values ...AnySimplelicensingLicenseExpression) {
	*o = append(*o, values...)
}
func (o *SimplelicensingLicenseExpressionList) Remove(value AnySimplelicensingLicenseExpression) {
	remove(o, value)
}

func (o *SimplelicensingLicenseExpressionList) SimplelicensingLicenseExpressionIter() iter.Seq2[AnySimplelicensingLicenseExpression, *SimplelicensingLicenseExpression] {
	return typeIter(*o, castSimplelicensingLicenseExpression)
}

// A license or addition that is not listed on the SPDX License List.
type SimplelicensingSimpleLicensingText struct {
	Element

	// Identifies the full text of a License or Addition.
	SimplelicensingLicenseText string
}

func castSimplelicensingSimpleLicensingText(o any) *SimplelicensingSimpleLicensingText {
	if o, ok := o.(AnySimplelicensingSimpleLicensingText); ok {
		return o.asSimplelicensingSimpleLicensingText()
	}
	return nil
}

func (o *SimplelicensingSimpleLicensingText) asSimplelicensingSimpleLicensingText() *SimplelicensingSimpleLicensingText {
	return o
}

type AnySimplelicensingSimpleLicensingText interface {
	AnyElement
	asSimplelicensingSimpleLicensingText() *SimplelicensingSimpleLicensingText
}

type SimplelicensingSimpleLicensingTextList []AnySimplelicensingSimpleLicensingText

func (o *SimplelicensingSimpleLicensingTextList) Append(values ...AnySimplelicensingSimpleLicensingText) {
	*o = append(*o, values...)
}
func (o *SimplelicensingSimpleLicensingTextList) Remove(value AnySimplelicensingSimpleLicensingText) {
	remove(o, value)
}

func (o *SimplelicensingSimpleLicensingTextList) SimplelicensingSimpleLicensingTextIter() iter.Seq2[AnySimplelicensingSimpleLicensingText, *SimplelicensingSimpleLicensingText] {
	return typeIter(*o, castSimplelicensingSimpleLicensingText)
}

// A canonical, unique, immutable identifier
type SoftwareContentIdentifier struct {
	IntegrityMethod

	// Specifies the type of the content identifier.
	SoftwareContentIdentifierType SoftwareContentIdentifierType
	// Specifies the value of the content identifier.
	SoftwareContentIdentifierValue string
}

func castSoftwareContentIdentifier(o any) *SoftwareContentIdentifier {
	if o, ok := o.(AnySoftwareContentIdentifier); ok {
		return o.asSoftwareContentIdentifier()
	}
	return nil
}

func (o *SoftwareContentIdentifier) asSoftwareContentIdentifier() *SoftwareContentIdentifier {
	return o
}

type AnySoftwareContentIdentifier interface {
	AnyIntegrityMethod
	asSoftwareContentIdentifier() *SoftwareContentIdentifier
}

type SoftwareContentIdentifierList []AnySoftwareContentIdentifier

func (o *SoftwareContentIdentifierList) Append(values ...AnySoftwareContentIdentifier) {
	*o = append(*o, values...)
}
func (o *SoftwareContentIdentifierList) Remove(value AnySoftwareContentIdentifier) { remove(o, value) }

func (o *SoftwareContentIdentifierList) SoftwareContentIdentifierIter() iter.Seq2[AnySoftwareContentIdentifier, *SoftwareContentIdentifier] {
	return typeIter(*o, castSoftwareContentIdentifier)
}

// Specifies the type of a content identifier.
type SoftwareContentIdentifierType struct {
	ID string
}

// [Gitoid](https://www.iana.org/assignments/uri-schemes/prov/gitoid), stands for [Git Object ID](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects). A gitoid of type blob is a unique hash of a binary artifact. A gitoid may represent either an [Artifact Identifier](https://github.com/omnibor/spec/blob/eb1ee5c961c16215eb8709b2975d193a2007a35d/spec/SPEC.md#artifact-identifier-types) for the software artifact or an [Input Manifest Identifier](https://github.com/omnibor/spec/blob/eb1ee5c961c16215eb8709b2975d193a2007a35d/spec/SPEC.md#input-manifest-identifier) for the software artifact's associated [Artifact Input Manifest](https://github.com/omnibor/spec/blob/eb1ee5c961c16215eb8709b2975d193a2007a35d/spec/SPEC.md#artifact-input-manifest); this ambiguity exists because the Artifact Input Manifest is itself an artifact, and the gitoid of that artifact is its valid identifier. Gitoids calculated on software artifacts (Snippet, File, or Package Elements) should be recorded in the SPDX 3.0 SoftwareArtifact's contentIdentifier property. Gitoids calculated on the Artifact Input Manifest (Input Manifest Identifier) should be recorded in the SPDX 3.0 Element's externalIdentifier property. See [OmniBOR Specification](https://github.com/omnibor/spec/), a minimalistic specification for describing software [Artifact Dependency Graphs](https://github.com/omnibor/spec/blob/eb1ee5c961c16215eb8709b2975d193a2007a35d/spec/SPEC.md#artifact-dependency-graph-adg).
var SoftwareContentIdentifierType_Gitoid = SoftwareContentIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Software/ContentIdentifierType/gitoid"}

// SoftWare Hash IDentifier, a persistent intrinsic identifier for digital artifacts, such as files, trees (also known as directories or folders), commits, and other objects typically found in version control systems. The format of the identifiers is defined in the [SWHID specification](https://www.swhid.org/specification/v1.1/4.Syntax) (ISO/IEC DIS 18670). They typically look like `swh:1:cnt:94a9ed024d3859793618152ea559a168bbcbb5e2`.
var SoftwareContentIdentifierType_Swhid = SoftwareContentIdentifierType{ID: "https://spdx.org/rdf/3.0.1/terms/Software/ContentIdentifierType/swhid"}

// Enumeration of the different kinds of SPDX file.
type SoftwareFileKindType struct {
	ID string
}

// The file represents a directory and all content stored in that directory.
var SoftwareFileKindType_Directory = SoftwareFileKindType{ID: "https://spdx.org/rdf/3.0.1/terms/Software/FileKindType/directory"}

// The file represents a single file (default).
var SoftwareFileKindType_File = SoftwareFileKindType{ID: "https://spdx.org/rdf/3.0.1/terms/Software/FileKindType/file"}

// Provides a set of values to be used to describe the common types of SBOMs that
// tools may create.
type SoftwareSbomType struct {
	ID string
}

// SBOM generated through analysis of artifacts (e.g., executables, packages, containers, and virtual machine images) after its build. Such analysis generally requires a variety of heuristics. In some contexts, this may also be referred to as a "3rd party" SBOM.
var SoftwareSbomType_Analyzed = SoftwareSbomType{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SbomType/analyzed"}

// SBOM generated as part of the process of building the software to create a releasable artifact (e.g., executable or package) from data such as source files, dependencies, built components, build process ephemeral data, and other SBOMs.
var SoftwareSbomType_Build = SoftwareSbomType{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SbomType/build"}

// SBOM provides an inventory of software that is present on a system. This may be an assembly of other SBOMs that combines analysis of configuration options, and examination of execution behavior in a (potentially simulated) deployment environment.
var SoftwareSbomType_Deployed = SoftwareSbomType{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SbomType/deployed"}

// SBOM of intended, planned software project or product with included components (some of which may not yet exist) for a new software artifact.
var SoftwareSbomType_Design = SoftwareSbomType{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SbomType/design"}

// SBOM generated through instrumenting the system running the software, to capture only components present in the system, as well as external call-outs or dynamically loaded components. In some contexts, this may also be referred to as an "Instrumented" or "Dynamic" SBOM.
var SoftwareSbomType_Runtime = SoftwareSbomType{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SbomType/runtime"}

// SBOM created directly from the development environment, source files, and included dependencies used to build an product artifact.
var SoftwareSbomType_Source = SoftwareSbomType{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SbomType/source"}

// Provides information about the primary purpose of an Element.
type SoftwareSoftwarePurpose struct {
	ID string
}

// The Element is a software application.
var SoftwareSoftwarePurpose_Application = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/application"}

// The Element is an archived collection of one or more files (.tar, .zip, etc.).
var SoftwareSoftwarePurpose_Archive = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/archive"}

// The Element is a bill of materials.
var SoftwareSoftwarePurpose_Bom = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/bom"}

// The Element is configuration data.
var SoftwareSoftwarePurpose_Configuration = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/configuration"}

// The Element is a container image which can be used by a container runtime application.
var SoftwareSoftwarePurpose_Container = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/container"}

// The Element is data.
var SoftwareSoftwarePurpose_Data = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/data"}

// The Element refers to a chipset, processor, or electronic board.
var SoftwareSoftwarePurpose_Device = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/device"}

// The Element represents software that controls hardware devices.
var SoftwareSoftwarePurpose_DeviceDriver = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/deviceDriver"}

// The Element refers to a disk image that can be written to a disk, booted in a VM, etc. A disk image typically contains most or all of the components necessary to boot, such as bootloaders, kernels, firmware, userspace, etc.
var SoftwareSoftwarePurpose_DiskImage = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/diskImage"}

// The Element is documentation.
var SoftwareSoftwarePurpose_Documentation = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/documentation"}

// The Element is the evidence that a specification or requirement has been fulfilled.
var SoftwareSoftwarePurpose_Evidence = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/evidence"}

// The Element is an Artifact that can be run on a computer.
var SoftwareSoftwarePurpose_Executable = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/executable"}

// The Element is a single file which can be independently distributed (configuration file, statically linked binary, Kubernetes deployment, etc.).
var SoftwareSoftwarePurpose_File = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/file"}

// The Element is a file system image that can be written to a disk (or virtual) partition.
var SoftwareSoftwarePurpose_FilesystemImage = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/filesystemImage"}

// The Element provides low level control over a device's hardware.
var SoftwareSoftwarePurpose_Firmware = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/firmware"}

// The Element is a software framework.
var SoftwareSoftwarePurpose_Framework = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/framework"}

// The Element is used to install software on disk.
var SoftwareSoftwarePurpose_Install = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/install"}

// The Element is a software library.
var SoftwareSoftwarePurpose_Library = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/library"}

// The Element is a software manifest.
var SoftwareSoftwarePurpose_Manifest = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/manifest"}

// The Element is a machine learning or artificial intelligence model.
var SoftwareSoftwarePurpose_Model = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/model"}

// The Element is a module of a piece of software.
var SoftwareSoftwarePurpose_Module = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/module"}

// The Element is an operating system.
var SoftwareSoftwarePurpose_OperatingSystem = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/operatingSystem"}

// The Element doesn't fit into any of the other categories.
var SoftwareSoftwarePurpose_Other = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/other"}

// The Element contains a set of changes to update, fix, or improve another Element.
var SoftwareSoftwarePurpose_Patch = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/patch"}

// The Element represents a runtime environment.
var SoftwareSoftwarePurpose_Platform = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/platform"}

// The Element provides a requirement needed as input for another Element.
var SoftwareSoftwarePurpose_Requirement = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/requirement"}

// The Element is a single or a collection of source files.
var SoftwareSoftwarePurpose_Source = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/source"}

// The Element is a plan, guideline or strategy how to create, perform or analyze an application.
var SoftwareSoftwarePurpose_Specification = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/specification"}

// The Element is a test used to verify functionality on an software element.
var SoftwareSoftwarePurpose_Test = SoftwareSoftwarePurpose{ID: "https://spdx.org/rdf/3.0.1/terms/Software/SoftwarePurpose/test"}

// Class that describes a build instance of software/artifacts.
type BuildBuild struct {
	Element

	// Property that describes the time at which a build stops.
	BuildBuildEndTime time.Time
	// A buildId is a locally unique identifier used by a builder to identify a unique
	// instance of a build produced by it.
	BuildBuildId string
	// Property describing the start time of a build.
	BuildBuildStartTime time.Time
	// A buildType is a hint that is used to indicate the toolchain, platform, or
	// infrastructure that the build was invoked on.
	BuildBuildType string
	// Property that describes the digest of the build configuration file used to
	// invoke a build.
	BuildConfigSourceDigests HashList

	// Property describes the invocation entrypoint of a build.
	BuildConfigSourceEntrypoints []string
	// Property that describes the URI of the build configuration source file.
	BuildConfigSourceUris []string
	// Property describing the session in which a build is invoked.
	BuildEnvironments DictionaryEntryList

	// Property describing a parameter used in an instance of a build.
	BuildParameters DictionaryEntryList
}

func castBuildBuild(o any) *BuildBuild {
	if o, ok := o.(AnyBuildBuild); ok {
		return o.asBuildBuild()
	}
	return nil
}

func (o *BuildBuild) asBuildBuild() *BuildBuild {
	return o
}

type AnyBuildBuild interface {
	AnyElement
	asBuildBuild() *BuildBuild
}

type BuildBuildList []AnyBuildBuild

func (o *BuildBuildList) Append(values ...AnyBuildBuild) { *o = append(*o, values...) }
func (o *BuildBuildList) Remove(value AnyBuildBuild)     { remove(o, value) }

func (o *BuildBuildList) BuildBuildIter() iter.Seq2[AnyBuildBuild, *BuildBuild] {
	return typeIter(*o, castBuildBuild)
}

// Agent represents anything with the potential to act on a system.
type Agent struct {
	Element
}

func castAgent(o any) *Agent {
	if o, ok := o.(AnyAgent); ok {
		return o.asAgent()
	}
	return nil
}

func (o *Agent) asAgent() *Agent {
	return o
}

type AnyAgent interface {
	AnyElement
	asAgent() *Agent
}

type AgentList []AnyAgent

func (o *AgentList) Append(values ...AnyAgent) { *o = append(*o, values...) }
func (o *AgentList) Remove(value AnyAgent)     { remove(o, value) }

func (o *AgentList) AgentIter() iter.Seq2[AnyAgent, *Agent] { return typeIter(*o, castAgent) }
func (o *AgentList) OrganizationIter() iter.Seq2[AnyAgent, *Organization] {
	return typeIter(*o, castOrganization)
}
func (o *AgentList) PersonIter() iter.Seq2[AnyAgent, *Person] { return typeIter(*o, castPerson) }
func (o *AgentList) SoftwareAgentIter() iter.Seq2[AnyAgent, *SoftwareAgent] {
	return typeIter(*o, castSoftwareAgent)
}

// An assertion made in relation to one or more elements.
type Annotation struct {
	Element

	// Describes the type of annotation.
	AnnotationType AnnotationType
	// Provides information about the content type of an Element or a Property.
	ContentType string
	// Commentary on an assertion that an annotator has made.
	Statement string
	// An Element an annotator has made an assertion about.
	Subject AnyElement
}

func castAnnotation(o any) *Annotation {
	if o, ok := o.(AnyAnnotation); ok {
		return o.asAnnotation()
	}
	return nil
}

func (o *Annotation) asAnnotation() *Annotation {
	return o
}

type AnyAnnotation interface {
	AnyElement
	asAnnotation() *Annotation
}

type AnnotationList []AnyAnnotation

func (o *AnnotationList) Append(values ...AnyAnnotation) { *o = append(*o, values...) }
func (o *AnnotationList) Remove(value AnyAnnotation)     { remove(o, value) }

func (o *AnnotationList) AnnotationIter() iter.Seq2[AnyAnnotation, *Annotation] {
	return typeIter(*o, castAnnotation)
}

// A distinct article or unit within the digital domain.
type Artifact struct {
	Element

	// Specifies the time an artifact was built.
	BuiltTime time.Time
	// Identifies from where or whom the Element originally came.
	OriginatedBys AgentList

	// Specifies the time an artifact was released.
	ReleaseTime time.Time
	// The name of a relevant standard that may apply to an artifact.
	StandardNames []string
	// Identifies who or what supplied the artifact or VulnAssessmentRelationship
	// referenced by the Element.
	SuppliedBy AnyAgent

	// Specifies the level of support associated with an artifact.
	SupportLevels []SupportType
	// Specifies until when the artifact can be used before its usage needs to be
	// reassessed.
	ValidUntilTime time.Time
}

func castArtifact(o any) *Artifact {
	if o, ok := o.(AnyArtifact); ok {
		return o.asArtifact()
	}
	return nil
}

func (o *Artifact) asArtifact() *Artifact {
	return o
}

type AnyArtifact interface {
	AnyElement
	asArtifact() *Artifact
}

type ArtifactList []AnyArtifact

func (o *ArtifactList) Append(values ...AnyArtifact) { *o = append(*o, values...) }
func (o *ArtifactList) Remove(value AnyArtifact)     { remove(o, value) }

func (o *ArtifactList) ArtifactIter() iter.Seq2[AnyArtifact, *Artifact] {
	return typeIter(*o, castArtifact)
}
func (o *ArtifactList) SecurityVulnerabilityIter() iter.Seq2[AnyArtifact, *SecurityVulnerability] {
	return typeIter(*o, castSecurityVulnerability)
}
func (o *ArtifactList) SoftwareSoftwareArtifactIter() iter.Seq2[AnyArtifact, *SoftwareSoftwareArtifact] {
	return typeIter(*o, castSoftwareSoftwareArtifact)
}
func (o *ArtifactList) SoftwareFileIter() iter.Seq2[AnyArtifact, *SoftwareFile] {
	return typeIter(*o, castSoftwareFile)
}
func (o *ArtifactList) SoftwarePackageIter() iter.Seq2[AnyArtifact, *SoftwarePackage] {
	return typeIter(*o, castSoftwarePackage)
}
func (o *ArtifactList) SoftwareSnippetIter() iter.Seq2[AnyArtifact, *SoftwareSnippet] {
	return typeIter(*o, castSoftwareSnippet)
}
func (o *ArtifactList) AiAIPackageIter() iter.Seq2[AnyArtifact, *AiAIPackage] {
	return typeIter(*o, castAiAIPackage)
}
func (o *ArtifactList) DatasetDatasetPackageIter() iter.Seq2[AnyArtifact, *DatasetDatasetPackage] {
	return typeIter(*o, castDatasetDatasetPackage)
}

// A collection of Elements that have a shared context.
type Bundle struct {
	ElementCollection

	// Gives information about the circumstances or unifying properties
	// that Elements of the bundle have been assembled under.
	Context string
}

func castBundle(o any) *Bundle {
	if o, ok := o.(AnyBundle); ok {
		return o.asBundle()
	}
	return nil
}

func (o *Bundle) asBundle() *Bundle {
	return o
}

type AnyBundle interface {
	AnyElementCollection
	asBundle() *Bundle
}

type BundleList []AnyBundle

func (o *BundleList) Append(values ...AnyBundle) { *o = append(*o, values...) }
func (o *BundleList) Remove(value AnyBundle)     { remove(o, value) }

func (o *BundleList) BundleIter() iter.Seq2[AnyBundle, *Bundle] { return typeIter(*o, castBundle) }
func (o *BundleList) BomIter() iter.Seq2[AnyBundle, *Bom]       { return typeIter(*o, castBom) }
func (o *BundleList) SoftwareSbomIter() iter.Seq2[AnyBundle, *SoftwareSbom] {
	return typeIter(*o, castSoftwareSbom)
}

// A mathematically calculated representation of a grouping of data.
type Hash struct {
	IntegrityMethod

	// Specifies the algorithm used for calculating the hash value.
	Algorithm HashAlgorithm
	// The result of applying a hash algorithm to an Element.
	HashValue string
}

func castHash(o any) *Hash {
	if o, ok := o.(AnyHash); ok {
		return o.asHash()
	}
	return nil
}

func (o *Hash) asHash() *Hash {
	return o
}

type AnyHash interface {
	AnyIntegrityMethod
	asHash() *Hash
}

type HashList []AnyHash

func (o *HashList) Append(values ...AnyHash) { *o = append(*o, values...) }
func (o *HashList) Remove(value AnyHash)     { remove(o, value) }

func (o *HashList) HashIter() iter.Seq2[AnyHash, *Hash] { return typeIter(*o, castHash) }

// Provide context for a relationship that occurs in the lifecycle.
type LifecycleScopedRelationship struct {
	Relationship

	// Capture the scope of information about a specific relationship between elements.
	Scope LifecycleScopeType
}

func castLifecycleScopedRelationship(o any) *LifecycleScopedRelationship {
	if o, ok := o.(AnyLifecycleScopedRelationship); ok {
		return o.asLifecycleScopedRelationship()
	}
	return nil
}

func (o *LifecycleScopedRelationship) asLifecycleScopedRelationship() *LifecycleScopedRelationship {
	return o
}

type AnyLifecycleScopedRelationship interface {
	AnyRelationship
	asLifecycleScopedRelationship() *LifecycleScopedRelationship
}

type LifecycleScopedRelationshipList []AnyLifecycleScopedRelationship

func (o *LifecycleScopedRelationshipList) Append(values ...AnyLifecycleScopedRelationship) {
	*o = append(*o, values...)
}
func (o *LifecycleScopedRelationshipList) Remove(value AnyLifecycleScopedRelationship) {
	remove(o, value)
}

func (o *LifecycleScopedRelationshipList) LifecycleScopedRelationshipIter() iter.Seq2[AnyLifecycleScopedRelationship, *LifecycleScopedRelationship] {
	return typeIter(*o, castLifecycleScopedRelationship)
}

// A group of people who work together in an organized way for a shared purpose.
type Organization struct {
	Agent
}

// An Organization representing the SPDX Project.
var Organization_SpdxOrganization = Organization{Agent: Agent{Element: Element{ID: "https://spdx.org/rdf/3.0.1/terms/Core/SpdxOrganization"}}}

func castOrganization(o any) *Organization {
	if o, ok := o.(AnyOrganization); ok {
		return o.asOrganization()
	}
	return nil
}

func (o *Organization) asOrganization() *Organization {
	return o
}

type AnyOrganization interface {
	AnyAgent
	asOrganization() *Organization
}

type OrganizationList []AnyOrganization

func (o *OrganizationList) Append(values ...AnyOrganization) { *o = append(*o, values...) }
func (o *OrganizationList) Remove(value AnyOrganization)     { remove(o, value) }

func (o *OrganizationList) OrganizationIter() iter.Seq2[AnyOrganization, *Organization] {
	return typeIter(*o, castOrganization)
}

// An individual human being.
type Person struct {
	Agent
}

func castPerson(o any) *Person {
	if o, ok := o.(AnyPerson); ok {
		return o.asPerson()
	}
	return nil
}

func (o *Person) asPerson() *Person {
	return o
}

type AnyPerson interface {
	AnyAgent
	asPerson() *Person
}

type PersonList []AnyPerson

func (o *PersonList) Append(values ...AnyPerson) { *o = append(*o, values...) }
func (o *PersonList) Remove(value AnyPerson)     { remove(o, value) }

func (o *PersonList) PersonIter() iter.Seq2[AnyPerson, *Person] { return typeIter(*o, castPerson) }

// A software agent.
type SoftwareAgent struct {
	Agent
}

func castSoftwareAgent(o any) *SoftwareAgent {
	if o, ok := o.(AnySoftwareAgent); ok {
		return o.asSoftwareAgent()
	}
	return nil
}

func (o *SoftwareAgent) asSoftwareAgent() *SoftwareAgent {
	return o
}

type AnySoftwareAgent interface {
	AnyAgent
	asSoftwareAgent() *SoftwareAgent
}

type SoftwareAgentList []AnySoftwareAgent

func (o *SoftwareAgentList) Append(values ...AnySoftwareAgent) { *o = append(*o, values...) }
func (o *SoftwareAgentList) Remove(value AnySoftwareAgent)     { remove(o, value) }

func (o *SoftwareAgentList) SoftwareAgentIter() iter.Seq2[AnySoftwareAgent, *SoftwareAgent] {
	return typeIter(*o, castSoftwareAgent)
}

// Portion of an AnyLicenseInfo representing a set of licensing information
// where all elements apply.
type ExpandedlicensingConjunctiveLicenseSet struct {
	SimplelicensingAnyLicenseInfo

	// A license expression participating in a license set.
	ExpandedlicensingMembers SimplelicensingAnyLicenseInfoList
}

func castExpandedlicensingConjunctiveLicenseSet(o any) *ExpandedlicensingConjunctiveLicenseSet {
	if o, ok := o.(AnyExpandedlicensingConjunctiveLicenseSet); ok {
		return o.asExpandedlicensingConjunctiveLicenseSet()
	}
	return nil
}

func (o *ExpandedlicensingConjunctiveLicenseSet) asExpandedlicensingConjunctiveLicenseSet() *ExpandedlicensingConjunctiveLicenseSet {
	return o
}

type AnyExpandedlicensingConjunctiveLicenseSet interface {
	AnySimplelicensingAnyLicenseInfo
	asExpandedlicensingConjunctiveLicenseSet() *ExpandedlicensingConjunctiveLicenseSet
}

type ExpandedlicensingConjunctiveLicenseSetList []AnyExpandedlicensingConjunctiveLicenseSet

func (o *ExpandedlicensingConjunctiveLicenseSetList) Append(values ...AnyExpandedlicensingConjunctiveLicenseSet) {
	*o = append(*o, values...)
}
func (o *ExpandedlicensingConjunctiveLicenseSetList) Remove(value AnyExpandedlicensingConjunctiveLicenseSet) {
	remove(o, value)
}

func (o *ExpandedlicensingConjunctiveLicenseSetList) ExpandedlicensingConjunctiveLicenseSetIter() iter.Seq2[AnyExpandedlicensingConjunctiveLicenseSet, *ExpandedlicensingConjunctiveLicenseSet] {
	return typeIter(*o, castExpandedlicensingConjunctiveLicenseSet)
}

// A license addition that is not listed on the SPDX Exceptions List.
type ExpandedlicensingCustomLicenseAddition struct {
	ExpandedlicensingLicenseAddition
}

func castExpandedlicensingCustomLicenseAddition(o any) *ExpandedlicensingCustomLicenseAddition {
	if o, ok := o.(AnyExpandedlicensingCustomLicenseAddition); ok {
		return o.asExpandedlicensingCustomLicenseAddition()
	}
	return nil
}

func (o *ExpandedlicensingCustomLicenseAddition) asExpandedlicensingCustomLicenseAddition() *ExpandedlicensingCustomLicenseAddition {
	return o
}

type AnyExpandedlicensingCustomLicenseAddition interface {
	AnyExpandedlicensingLicenseAddition
	asExpandedlicensingCustomLicenseAddition() *ExpandedlicensingCustomLicenseAddition
}

type ExpandedlicensingCustomLicenseAdditionList []AnyExpandedlicensingCustomLicenseAddition

func (o *ExpandedlicensingCustomLicenseAdditionList) Append(values ...AnyExpandedlicensingCustomLicenseAddition) {
	*o = append(*o, values...)
}
func (o *ExpandedlicensingCustomLicenseAdditionList) Remove(value AnyExpandedlicensingCustomLicenseAddition) {
	remove(o, value)
}

func (o *ExpandedlicensingCustomLicenseAdditionList) ExpandedlicensingCustomLicenseAdditionIter() iter.Seq2[AnyExpandedlicensingCustomLicenseAddition, *ExpandedlicensingCustomLicenseAddition] {
	return typeIter(*o, castExpandedlicensingCustomLicenseAddition)
}

// Portion of an AnyLicenseInfo representing a set of licensing information where
// only one of the elements applies.
type ExpandedlicensingDisjunctiveLicenseSet struct {
	SimplelicensingAnyLicenseInfo

	// A license expression participating in a license set.
	ExpandedlicensingMembers SimplelicensingAnyLicenseInfoList
}

func castExpandedlicensingDisjunctiveLicenseSet(o any) *ExpandedlicensingDisjunctiveLicenseSet {
	if o, ok := o.(AnyExpandedlicensingDisjunctiveLicenseSet); ok {
		return o.asExpandedlicensingDisjunctiveLicenseSet()
	}
	return nil
}

func (o *ExpandedlicensingDisjunctiveLicenseSet) asExpandedlicensingDisjunctiveLicenseSet() *ExpandedlicensingDisjunctiveLicenseSet {
	return o
}

type AnyExpandedlicensingDisjunctiveLicenseSet interface {
	AnySimplelicensingAnyLicenseInfo
	asExpandedlicensingDisjunctiveLicenseSet() *ExpandedlicensingDisjunctiveLicenseSet
}

type ExpandedlicensingDisjunctiveLicenseSetList []AnyExpandedlicensingDisjunctiveLicenseSet

func (o *ExpandedlicensingDisjunctiveLicenseSetList) Append(values ...AnyExpandedlicensingDisjunctiveLicenseSet) {
	*o = append(*o, values...)
}
func (o *ExpandedlicensingDisjunctiveLicenseSetList) Remove(value AnyExpandedlicensingDisjunctiveLicenseSet) {
	remove(o, value)
}

func (o *ExpandedlicensingDisjunctiveLicenseSetList) ExpandedlicensingDisjunctiveLicenseSetIter() iter.Seq2[AnyExpandedlicensingDisjunctiveLicenseSet, *ExpandedlicensingDisjunctiveLicenseSet] {
	return typeIter(*o, castExpandedlicensingDisjunctiveLicenseSet)
}

// Abstract class representing a License or an OrLaterOperator.
type ExpandedlicensingExtendableLicense struct {
	SimplelicensingAnyLicenseInfo
}

func castExpandedlicensingExtendableLicense(o any) *ExpandedlicensingExtendableLicense {
	if o, ok := o.(AnyExpandedlicensingExtendableLicense); ok {
		return o.asExpandedlicensingExtendableLicense()
	}
	return nil
}

func (o *ExpandedlicensingExtendableLicense) asExpandedlicensingExtendableLicense() *ExpandedlicensingExtendableLicense {
	return o
}

type AnyExpandedlicensingExtendableLicense interface {
	AnySimplelicensingAnyLicenseInfo
	asExpandedlicensingExtendableLicense() *ExpandedlicensingExtendableLicense
}

type ExpandedlicensingExtendableLicenseList []AnyExpandedlicensingExtendableLicense

func (o *ExpandedlicensingExtendableLicenseList) Append(values ...AnyExpandedlicensingExtendableLicense) {
	*o = append(*o, values...)
}
func (o *ExpandedlicensingExtendableLicenseList) Remove(value AnyExpandedlicensingExtendableLicense) {
	remove(o, value)
}

func (o *ExpandedlicensingExtendableLicenseList) ExpandedlicensingExtendableLicenseIter() iter.Seq2[AnyExpandedlicensingExtendableLicense, *ExpandedlicensingExtendableLicense] {
	return typeIter(*o, castExpandedlicensingExtendableLicense)
}
func (o *ExpandedlicensingExtendableLicenseList) ExpandedlicensingLicenseIter() iter.Seq2[AnyExpandedlicensingExtendableLicense, *ExpandedlicensingLicense] {
	return typeIter(*o, castExpandedlicensingLicense)
}
func (o *ExpandedlicensingExtendableLicenseList) ExpandedlicensingListedLicenseIter() iter.Seq2[AnyExpandedlicensingExtendableLicense, *ExpandedlicensingListedLicense] {
	return typeIter(*o, castExpandedlicensingListedLicense)
}
func (o *ExpandedlicensingExtendableLicenseList) ExpandedlicensingOrLaterOperatorIter() iter.Seq2[AnyExpandedlicensingExtendableLicense, *ExpandedlicensingOrLaterOperator] {
	return typeIter(*o, castExpandedlicensingOrLaterOperator)
}
func (o *ExpandedlicensingExtendableLicenseList) ExpandedlicensingCustomLicenseIter() iter.Seq2[AnyExpandedlicensingExtendableLicense, *ExpandedlicensingCustomLicense] {
	return typeIter(*o, castExpandedlicensingCustomLicense)
}

// A concrete subclass of AnyLicenseInfo used by Individuals in the
// ExpandedLicensing profile.
type ExpandedlicensingIndividualLicensingInfo struct {
	SimplelicensingAnyLicenseInfo
}

// An Individual Value for License when no assertion can be made about its actual
// value.
var ExpandedlicensingIndividualLicensingInfo_NoAssertionLicense = ExpandedlicensingIndividualLicensingInfo{SimplelicensingAnyLicenseInfo: SimplelicensingAnyLicenseInfo{Element: Element{ID: "https://spdx.org/rdf/3.0.1/terms/ExpandedLicensing/NoAssertionLicense"}}}

// An Individual Value for License where the SPDX data creator determines that no
// license is present.
var ExpandedlicensingIndividualLicensingInfo_NoneLicense = ExpandedlicensingIndividualLicensingInfo{SimplelicensingAnyLicenseInfo: SimplelicensingAnyLicenseInfo{Element: Element{ID: "https://spdx.org/rdf/3.0.1/terms/ExpandedLicensing/NoneLicense"}}}

func castExpandedlicensingIndividualLicensingInfo(o any) *ExpandedlicensingIndividualLicensingInfo {
	if o, ok := o.(AnyExpandedlicensingIndividualLicensingInfo); ok {
		return o.asExpandedlicensingIndividualLicensingInfo()
	}
	return nil
}

func (o *ExpandedlicensingIndividualLicensingInfo) asExpandedlicensingIndividualLicensingInfo() *ExpandedlicensingIndividualLicensingInfo {
	return o
}

type AnyExpandedlicensingIndividualLicensingInfo interface {
	AnySimplelicensingAnyLicenseInfo
	asExpandedlicensingIndividualLicensingInfo() *ExpandedlicensingIndividualLicensingInfo
}

type ExpandedlicensingIndividualLicensingInfoList []AnyExpandedlicensingIndividualLicensingInfo

func (o *ExpandedlicensingIndividualLicensingInfoList) Append(values ...AnyExpandedlicensingIndividualLicensingInfo) {
	*o = append(*o, values...)
}
func (o *ExpandedlicensingIndividualLicensingInfoList) Remove(value AnyExpandedlicensingIndividualLicensingInfo) {
	remove(o, value)
}

func (o *ExpandedlicensingIndividualLicensingInfoList) ExpandedlicensingIndividualLicensingInfoIter() iter.Seq2[AnyExpandedlicensingIndividualLicensingInfo, *ExpandedlicensingIndividualLicensingInfo] {
	return typeIter(*o, castExpandedlicensingIndividualLicensingInfo)
}

// Abstract class for the portion of an AnyLicenseInfo representing a license.
type ExpandedlicensingLicense struct {
	ExpandedlicensingExtendableLicense

	// Specifies whether a license or additional text identifier has been marked as
	// deprecated.
	ExpandedlicensingIsDeprecatedLicenseId bool
	// Specifies whether the License is listed as free by the
	// Free Software Foundation (FSF).
	ExpandedlicensingIsFsfLibre bool
	// Specifies whether the License is listed as approved by the
	// Open Source Initiative (OSI).
	ExpandedlicensingIsOsiApproved bool
	// Identifies all the text and metadata associated with a license in the license
	// XML format.
	ExpandedlicensingLicenseXml string
	// Specifies the licenseId that is preferred to be used in place of a deprecated
	// License or LicenseAddition.
	ExpandedlicensingObsoletedBy string
	// Contains a URL where the License or LicenseAddition can be found in use.
	ExpandedlicensingSeeAlsos []string
	// Provides a License author's preferred text to indicate that a file is covered
	// by the License.
	ExpandedlicensingStandardLicenseHeader string
	// Identifies the full text of a License, in SPDX templating format.
	ExpandedlicensingStandardLicenseTemplate string
	// Identifies the full text of a License or Addition.
	SimplelicensingLicenseText string
}

func castExpandedlicensingLicense(o any) *ExpandedlicensingLicense {
	if o, ok := o.(AnyExpandedlicensingLicense); ok {
		return o.asExpandedlicensingLicense()
	}
	return nil
}

func (o *ExpandedlicensingLicense) asExpandedlicensingLicense() *ExpandedlicensingLicense {
	return o
}

type AnyExpandedlicensingLicense interface {
	AnyExpandedlicensingExtendableLicense
	asExpandedlicensingLicense() *ExpandedlicensingLicense
}

type ExpandedlicensingLicenseList []AnyExpandedlicensingLicense

func (o *ExpandedlicensingLicenseList) Append(values ...AnyExpandedlicensingLicense) {
	*o = append(*o, values...)
}
func (o *ExpandedlicensingLicenseList) Remove(value AnyExpandedlicensingLicense) { remove(o, value) }

func (o *ExpandedlicensingLicenseList) ExpandedlicensingLicenseIter() iter.Seq2[AnyExpandedlicensingLicense, *ExpandedlicensingLicense] {
	return typeIter(*o, castExpandedlicensingLicense)
}
func (o *ExpandedlicensingLicenseList) ExpandedlicensingListedLicenseIter() iter.Seq2[AnyExpandedlicensingLicense, *ExpandedlicensingListedLicense] {
	return typeIter(*o, castExpandedlicensingListedLicense)
}
func (o *ExpandedlicensingLicenseList) ExpandedlicensingCustomLicenseIter() iter.Seq2[AnyExpandedlicensingLicense, *ExpandedlicensingCustomLicense] {
	return typeIter(*o, castExpandedlicensingCustomLicense)
}

// A license that is listed on the SPDX License List.
type ExpandedlicensingListedLicense struct {
	ExpandedlicensingLicense

	// Specifies the SPDX License List version in which this license or exception
	// identifier was deprecated.
	ExpandedlicensingDeprecatedVersion string
	// Specifies the SPDX License List version in which this ListedLicense or
	// ListedLicenseException identifier was first added.
	ExpandedlicensingListVersionAdded string
}

func castExpandedlicensingListedLicense(o any) *ExpandedlicensingListedLicense {
	if o, ok := o.(AnyExpandedlicensingListedLicense); ok {
		return o.asExpandedlicensingListedLicense()
	}
	return nil
}

func (o *ExpandedlicensingListedLicense) asExpandedlicensingListedLicense() *ExpandedlicensingListedLicense {
	return o
}

type AnyExpandedlicensingListedLicense interface {
	AnyExpandedlicensingLicense
	asExpandedlicensingListedLicense() *ExpandedlicensingListedLicense
}

type ExpandedlicensingListedLicenseList []AnyExpandedlicensingListedLicense

func (o *ExpandedlicensingListedLicenseList) Append(values ...AnyExpandedlicensingListedLicense) {
	*o = append(*o, values...)
}
func (o *ExpandedlicensingListedLicenseList) Remove(value AnyExpandedlicensingListedLicense) {
	remove(o, value)
}

func (o *ExpandedlicensingListedLicenseList) ExpandedlicensingListedLicenseIter() iter.Seq2[AnyExpandedlicensingListedLicense, *ExpandedlicensingListedLicense] {
	return typeIter(*o, castExpandedlicensingListedLicense)
}

// Portion of an AnyLicenseInfo representing this version, or any later version,
// of the indicated License.
type ExpandedlicensingOrLaterOperator struct {
	ExpandedlicensingExtendableLicense

	// A License participating in an 'or later' model.
	ExpandedlicensingSubjectLicense AnyExpandedlicensingLicense
}

func castExpandedlicensingOrLaterOperator(o any) *ExpandedlicensingOrLaterOperator {
	if o, ok := o.(AnyExpandedlicensingOrLaterOperator); ok {
		return o.asExpandedlicensingOrLaterOperator()
	}
	return nil
}

func (o *ExpandedlicensingOrLaterOperator) asExpandedlicensingOrLaterOperator() *ExpandedlicensingOrLaterOperator {
	return o
}

type AnyExpandedlicensingOrLaterOperator interface {
	AnyExpandedlicensingExtendableLicense
	asExpandedlicensingOrLaterOperator() *ExpandedlicensingOrLaterOperator
}

type ExpandedlicensingOrLaterOperatorList []AnyExpandedlicensingOrLaterOperator

func (o *ExpandedlicensingOrLaterOperatorList) Append(values ...AnyExpandedlicensingOrLaterOperator) {
	*o = append(*o, values...)
}
func (o *ExpandedlicensingOrLaterOperatorList) Remove(value AnyExpandedlicensingOrLaterOperator) {
	remove(o, value)
}

func (o *ExpandedlicensingOrLaterOperatorList) ExpandedlicensingOrLaterOperatorIter() iter.Seq2[AnyExpandedlicensingOrLaterOperator, *ExpandedlicensingOrLaterOperator] {
	return typeIter(*o, castExpandedlicensingOrLaterOperator)
}

// Portion of an AnyLicenseInfo representing a License which has additional
// text applied to it.
type ExpandedlicensingWithAdditionOperator struct {
	SimplelicensingAnyLicenseInfo

	// A LicenseAddition participating in a 'with addition' model.
	ExpandedlicensingSubjectAddition AnyExpandedlicensingLicenseAddition

	// A License participating in a 'with addition' model.
	ExpandedlicensingSubjectExtendableLicense AnyExpandedlicensingExtendableLicense
}

func castExpandedlicensingWithAdditionOperator(o any) *ExpandedlicensingWithAdditionOperator {
	if o, ok := o.(AnyExpandedlicensingWithAdditionOperator); ok {
		return o.asExpandedlicensingWithAdditionOperator()
	}
	return nil
}

func (o *ExpandedlicensingWithAdditionOperator) asExpandedlicensingWithAdditionOperator() *ExpandedlicensingWithAdditionOperator {
	return o
}

type AnyExpandedlicensingWithAdditionOperator interface {
	AnySimplelicensingAnyLicenseInfo
	asExpandedlicensingWithAdditionOperator() *ExpandedlicensingWithAdditionOperator
}

type ExpandedlicensingWithAdditionOperatorList []AnyExpandedlicensingWithAdditionOperator

func (o *ExpandedlicensingWithAdditionOperatorList) Append(values ...AnyExpandedlicensingWithAdditionOperator) {
	*o = append(*o, values...)
}
func (o *ExpandedlicensingWithAdditionOperatorList) Remove(value AnyExpandedlicensingWithAdditionOperator) {
	remove(o, value)
}

func (o *ExpandedlicensingWithAdditionOperatorList) ExpandedlicensingWithAdditionOperatorIter() iter.Seq2[AnyExpandedlicensingWithAdditionOperator, *ExpandedlicensingWithAdditionOperator] {
	return typeIter(*o, castExpandedlicensingWithAdditionOperator)
}

// A type of extension consisting of a list of name value pairs.
type ExtensionCdxPropertiesExtension struct {
	ExtensionExtension

	// Provides a map of a property names to a values.
	ExtensionCdxPropertys ExtensionCdxPropertyEntryList
}

func castExtensionCdxPropertiesExtension(o any) *ExtensionCdxPropertiesExtension {
	if o, ok := o.(AnyExtensionCdxPropertiesExtension); ok {
		return o.asExtensionCdxPropertiesExtension()
	}
	return nil
}

func (o *ExtensionCdxPropertiesExtension) asExtensionCdxPropertiesExtension() *ExtensionCdxPropertiesExtension {
	return o
}

type AnyExtensionCdxPropertiesExtension interface {
	AnyExtensionExtension
	asExtensionCdxPropertiesExtension() *ExtensionCdxPropertiesExtension
}

type ExtensionCdxPropertiesExtensionList []AnyExtensionCdxPropertiesExtension

func (o *ExtensionCdxPropertiesExtensionList) Append(values ...AnyExtensionCdxPropertiesExtension) {
	*o = append(*o, values...)
}
func (o *ExtensionCdxPropertiesExtensionList) Remove(value AnyExtensionCdxPropertiesExtension) {
	remove(o, value)
}

func (o *ExtensionCdxPropertiesExtensionList) ExtensionCdxPropertiesExtensionIter() iter.Seq2[AnyExtensionCdxPropertiesExtension, *ExtensionCdxPropertiesExtension] {
	return typeIter(*o, castExtensionCdxPropertiesExtension)
}

// Provides a CVSS version 2.0 assessment for a vulnerability.
type SecurityCvssV2VulnAssessmentRelationship struct {
	SecurityVulnAssessmentRelationship

	// Provides a numerical (0-10) representation of the severity of a vulnerability.
	SecurityScore float64
	// Specifies the CVSS vector string for a vulnerability.
	SecurityVectorString string
}

func castSecurityCvssV2VulnAssessmentRelationship(o any) *SecurityCvssV2VulnAssessmentRelationship {
	if o, ok := o.(AnySecurityCvssV2VulnAssessmentRelationship); ok {
		return o.asSecurityCvssV2VulnAssessmentRelationship()
	}
	return nil
}

func (o *SecurityCvssV2VulnAssessmentRelationship) asSecurityCvssV2VulnAssessmentRelationship() *SecurityCvssV2VulnAssessmentRelationship {
	return o
}

type AnySecurityCvssV2VulnAssessmentRelationship interface {
	AnySecurityVulnAssessmentRelationship
	asSecurityCvssV2VulnAssessmentRelationship() *SecurityCvssV2VulnAssessmentRelationship
}

type SecurityCvssV2VulnAssessmentRelationshipList []AnySecurityCvssV2VulnAssessmentRelationship

func (o *SecurityCvssV2VulnAssessmentRelationshipList) Append(values ...AnySecurityCvssV2VulnAssessmentRelationship) {
	*o = append(*o, values...)
}
func (o *SecurityCvssV2VulnAssessmentRelationshipList) Remove(value AnySecurityCvssV2VulnAssessmentRelationship) {
	remove(o, value)
}

func (o *SecurityCvssV2VulnAssessmentRelationshipList) SecurityCvssV2VulnAssessmentRelationshipIter() iter.Seq2[AnySecurityCvssV2VulnAssessmentRelationship, *SecurityCvssV2VulnAssessmentRelationship] {
	return typeIter(*o, castSecurityCvssV2VulnAssessmentRelationship)
}

// Provides a CVSS version 3 assessment for a vulnerability.
type SecurityCvssV3VulnAssessmentRelationship struct {
	SecurityVulnAssessmentRelationship

	// Provides a numerical (0-10) representation of the severity of a vulnerability.
	SecurityScore float64
	// Specifies the CVSS qualitative severity rating of a vulnerability in relation to a piece of software.
	SecuritySeverity SecurityCvssSeverityType
	// Specifies the CVSS vector string for a vulnerability.
	SecurityVectorString string
}

func castSecurityCvssV3VulnAssessmentRelationship(o any) *SecurityCvssV3VulnAssessmentRelationship {
	if o, ok := o.(AnySecurityCvssV3VulnAssessmentRelationship); ok {
		return o.asSecurityCvssV3VulnAssessmentRelationship()
	}
	return nil
}

func (o *SecurityCvssV3VulnAssessmentRelationship) asSecurityCvssV3VulnAssessmentRelationship() *SecurityCvssV3VulnAssessmentRelationship {
	return o
}

type AnySecurityCvssV3VulnAssessmentRelationship interface {
	AnySecurityVulnAssessmentRelationship
	asSecurityCvssV3VulnAssessmentRelationship() *SecurityCvssV3VulnAssessmentRelationship
}

type SecurityCvssV3VulnAssessmentRelationshipList []AnySecurityCvssV3VulnAssessmentRelationship

func (o *SecurityCvssV3VulnAssessmentRelationshipList) Append(values ...AnySecurityCvssV3VulnAssessmentRelationship) {
	*o = append(*o, values...)
}
func (o *SecurityCvssV3VulnAssessmentRelationshipList) Remove(value AnySecurityCvssV3VulnAssessmentRelationship) {
	remove(o, value)
}

func (o *SecurityCvssV3VulnAssessmentRelationshipList) SecurityCvssV3VulnAssessmentRelationshipIter() iter.Seq2[AnySecurityCvssV3VulnAssessmentRelationship, *SecurityCvssV3VulnAssessmentRelationship] {
	return typeIter(*o, castSecurityCvssV3VulnAssessmentRelationship)
}

// Provides a CVSS version 4 assessment for a vulnerability.
type SecurityCvssV4VulnAssessmentRelationship struct {
	SecurityVulnAssessmentRelationship

	// Provides a numerical (0-10) representation of the severity of a vulnerability.
	SecurityScore float64
	// Specifies the CVSS qualitative severity rating of a vulnerability in relation to a piece of software.
	SecuritySeverity SecurityCvssSeverityType
	// Specifies the CVSS vector string for a vulnerability.
	SecurityVectorString string
}

func castSecurityCvssV4VulnAssessmentRelationship(o any) *SecurityCvssV4VulnAssessmentRelationship {
	if o, ok := o.(AnySecurityCvssV4VulnAssessmentRelationship); ok {
		return o.asSecurityCvssV4VulnAssessmentRelationship()
	}
	return nil
}

func (o *SecurityCvssV4VulnAssessmentRelationship) asSecurityCvssV4VulnAssessmentRelationship() *SecurityCvssV4VulnAssessmentRelationship {
	return o
}

type AnySecurityCvssV4VulnAssessmentRelationship interface {
	AnySecurityVulnAssessmentRelationship
	asSecurityCvssV4VulnAssessmentRelationship() *SecurityCvssV4VulnAssessmentRelationship
}

type SecurityCvssV4VulnAssessmentRelationshipList []AnySecurityCvssV4VulnAssessmentRelationship

func (o *SecurityCvssV4VulnAssessmentRelationshipList) Append(values ...AnySecurityCvssV4VulnAssessmentRelationship) {
	*o = append(*o, values...)
}
func (o *SecurityCvssV4VulnAssessmentRelationshipList) Remove(value AnySecurityCvssV4VulnAssessmentRelationship) {
	remove(o, value)
}

func (o *SecurityCvssV4VulnAssessmentRelationshipList) SecurityCvssV4VulnAssessmentRelationshipIter() iter.Seq2[AnySecurityCvssV4VulnAssessmentRelationship, *SecurityCvssV4VulnAssessmentRelationship] {
	return typeIter(*o, castSecurityCvssV4VulnAssessmentRelationship)
}

// Provides an EPSS assessment for a vulnerability.
type SecurityEpssVulnAssessmentRelationship struct {
	SecurityVulnAssessmentRelationship

	// The percentile of the current probability score.
	SecurityPercentile float64
	// A probability score between 0 and 1 of a vulnerability being exploited.
	SecurityProbability float64
}

func castSecurityEpssVulnAssessmentRelationship(o any) *SecurityEpssVulnAssessmentRelationship {
	if o, ok := o.(AnySecurityEpssVulnAssessmentRelationship); ok {
		return o.asSecurityEpssVulnAssessmentRelationship()
	}
	return nil
}

func (o *SecurityEpssVulnAssessmentRelationship) asSecurityEpssVulnAssessmentRelationship() *SecurityEpssVulnAssessmentRelationship {
	return o
}

type AnySecurityEpssVulnAssessmentRelationship interface {
	AnySecurityVulnAssessmentRelationship
	asSecurityEpssVulnAssessmentRelationship() *SecurityEpssVulnAssessmentRelationship
}

type SecurityEpssVulnAssessmentRelationshipList []AnySecurityEpssVulnAssessmentRelationship

func (o *SecurityEpssVulnAssessmentRelationshipList) Append(values ...AnySecurityEpssVulnAssessmentRelationship) {
	*o = append(*o, values...)
}
func (o *SecurityEpssVulnAssessmentRelationshipList) Remove(value AnySecurityEpssVulnAssessmentRelationship) {
	remove(o, value)
}

func (o *SecurityEpssVulnAssessmentRelationshipList) SecurityEpssVulnAssessmentRelationshipIter() iter.Seq2[AnySecurityEpssVulnAssessmentRelationship, *SecurityEpssVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityEpssVulnAssessmentRelationship)
}

// Provides an exploit assessment of a vulnerability.
type SecurityExploitCatalogVulnAssessmentRelationship struct {
	SecurityVulnAssessmentRelationship

	// Specifies the exploit catalog type.
	SecurityCatalogType SecurityExploitCatalogType
	// Describe that a CVE is known to have an exploit because it's been listed in an exploit catalog.
	SecurityExploited bool
	// Provides the location of an exploit catalog.
	SecurityLocator string
}

func castSecurityExploitCatalogVulnAssessmentRelationship(o any) *SecurityExploitCatalogVulnAssessmentRelationship {
	if o, ok := o.(AnySecurityExploitCatalogVulnAssessmentRelationship); ok {
		return o.asSecurityExploitCatalogVulnAssessmentRelationship()
	}
	return nil
}

func (o *SecurityExploitCatalogVulnAssessmentRelationship) asSecurityExploitCatalogVulnAssessmentRelationship() *SecurityExploitCatalogVulnAssessmentRelationship {
	return o
}

type AnySecurityExploitCatalogVulnAssessmentRelationship interface {
	AnySecurityVulnAssessmentRelationship
	asSecurityExploitCatalogVulnAssessmentRelationship() *SecurityExploitCatalogVulnAssessmentRelationship
}

type SecurityExploitCatalogVulnAssessmentRelationshipList []AnySecurityExploitCatalogVulnAssessmentRelationship

func (o *SecurityExploitCatalogVulnAssessmentRelationshipList) Append(values ...AnySecurityExploitCatalogVulnAssessmentRelationship) {
	*o = append(*o, values...)
}
func (o *SecurityExploitCatalogVulnAssessmentRelationshipList) Remove(value AnySecurityExploitCatalogVulnAssessmentRelationship) {
	remove(o, value)
}

func (o *SecurityExploitCatalogVulnAssessmentRelationshipList) SecurityExploitCatalogVulnAssessmentRelationshipIter() iter.Seq2[AnySecurityExploitCatalogVulnAssessmentRelationship, *SecurityExploitCatalogVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityExploitCatalogVulnAssessmentRelationship)
}

// Provides an SSVC assessment for a vulnerability.
type SecuritySsvcVulnAssessmentRelationship struct {
	SecurityVulnAssessmentRelationship

	// Provide the enumeration of possible decisions in the
	// [Stakeholder-Specific Vulnerability Categorization (SSVC) decision tree](https://www.cisa.gov/stakeholder-specific-vulnerability-categorization-ssvc).
	SecurityDecisionType SecuritySsvcDecisionType
}

func castSecuritySsvcVulnAssessmentRelationship(o any) *SecuritySsvcVulnAssessmentRelationship {
	if o, ok := o.(AnySecuritySsvcVulnAssessmentRelationship); ok {
		return o.asSecuritySsvcVulnAssessmentRelationship()
	}
	return nil
}

func (o *SecuritySsvcVulnAssessmentRelationship) asSecuritySsvcVulnAssessmentRelationship() *SecuritySsvcVulnAssessmentRelationship {
	return o
}

type AnySecuritySsvcVulnAssessmentRelationship interface {
	AnySecurityVulnAssessmentRelationship
	asSecuritySsvcVulnAssessmentRelationship() *SecuritySsvcVulnAssessmentRelationship
}

type SecuritySsvcVulnAssessmentRelationshipList []AnySecuritySsvcVulnAssessmentRelationship

func (o *SecuritySsvcVulnAssessmentRelationshipList) Append(values ...AnySecuritySsvcVulnAssessmentRelationship) {
	*o = append(*o, values...)
}
func (o *SecuritySsvcVulnAssessmentRelationshipList) Remove(value AnySecuritySsvcVulnAssessmentRelationship) {
	remove(o, value)
}

func (o *SecuritySsvcVulnAssessmentRelationshipList) SecuritySsvcVulnAssessmentRelationshipIter() iter.Seq2[AnySecuritySsvcVulnAssessmentRelationship, *SecuritySsvcVulnAssessmentRelationship] {
	return typeIter(*o, castSecuritySsvcVulnAssessmentRelationship)
}

// Abstract ancestor class for all VEX relationships
type SecurityVexVulnAssessmentRelationship struct {
	SecurityVulnAssessmentRelationship

	// Conveys information about how VEX status was determined.
	SecurityStatusNotes string
	// Specifies the version of a VEX statement.
	SecurityVexVersion string
}

func castSecurityVexVulnAssessmentRelationship(o any) *SecurityVexVulnAssessmentRelationship {
	if o, ok := o.(AnySecurityVexVulnAssessmentRelationship); ok {
		return o.asSecurityVexVulnAssessmentRelationship()
	}
	return nil
}

func (o *SecurityVexVulnAssessmentRelationship) asSecurityVexVulnAssessmentRelationship() *SecurityVexVulnAssessmentRelationship {
	return o
}

type AnySecurityVexVulnAssessmentRelationship interface {
	AnySecurityVulnAssessmentRelationship
	asSecurityVexVulnAssessmentRelationship() *SecurityVexVulnAssessmentRelationship
}

type SecurityVexVulnAssessmentRelationshipList []AnySecurityVexVulnAssessmentRelationship

func (o *SecurityVexVulnAssessmentRelationshipList) Append(values ...AnySecurityVexVulnAssessmentRelationship) {
	*o = append(*o, values...)
}
func (o *SecurityVexVulnAssessmentRelationshipList) Remove(value AnySecurityVexVulnAssessmentRelationship) {
	remove(o, value)
}

func (o *SecurityVexVulnAssessmentRelationshipList) SecurityVexVulnAssessmentRelationshipIter() iter.Seq2[AnySecurityVexVulnAssessmentRelationship, *SecurityVexVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexVulnAssessmentRelationship)
}
func (o *SecurityVexVulnAssessmentRelationshipList) SecurityVexAffectedVulnAssessmentRelationshipIter() iter.Seq2[AnySecurityVexVulnAssessmentRelationship, *SecurityVexAffectedVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexAffectedVulnAssessmentRelationship)
}
func (o *SecurityVexVulnAssessmentRelationshipList) SecurityVexFixedVulnAssessmentRelationshipIter() iter.Seq2[AnySecurityVexVulnAssessmentRelationship, *SecurityVexFixedVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexFixedVulnAssessmentRelationship)
}
func (o *SecurityVexVulnAssessmentRelationshipList) SecurityVexNotAffectedVulnAssessmentRelationshipIter() iter.Seq2[AnySecurityVexVulnAssessmentRelationship, *SecurityVexNotAffectedVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexNotAffectedVulnAssessmentRelationship)
}
func (o *SecurityVexVulnAssessmentRelationshipList) SecurityVexUnderInvestigationVulnAssessmentRelationshipIter() iter.Seq2[AnySecurityVexVulnAssessmentRelationship, *SecurityVexUnderInvestigationVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexUnderInvestigationVulnAssessmentRelationship)
}

// Specifies a vulnerability and its associated information.
type SecurityVulnerability struct {
	Artifact

	// Specifies a time when a vulnerability assessment was modified
	SecurityModifiedTime time.Time
	// Specifies the time when a vulnerability was published.
	SecurityPublishedTime time.Time
	// Specified the time and date when a vulnerability was withdrawn.
	SecurityWithdrawnTime time.Time
}

func castSecurityVulnerability(o any) *SecurityVulnerability {
	if o, ok := o.(AnySecurityVulnerability); ok {
		return o.asSecurityVulnerability()
	}
	return nil
}

func (o *SecurityVulnerability) asSecurityVulnerability() *SecurityVulnerability {
	return o
}

type AnySecurityVulnerability interface {
	AnyArtifact
	asSecurityVulnerability() *SecurityVulnerability
}

type SecurityVulnerabilityList []AnySecurityVulnerability

func (o *SecurityVulnerabilityList) Append(values ...AnySecurityVulnerability) {
	*o = append(*o, values...)
}
func (o *SecurityVulnerabilityList) Remove(value AnySecurityVulnerability) { remove(o, value) }

func (o *SecurityVulnerabilityList) SecurityVulnerabilityIter() iter.Seq2[AnySecurityVulnerability, *SecurityVulnerability] {
	return typeIter(*o, castSecurityVulnerability)
}

// A distinct article or unit related to Software.
type SoftwareSoftwareArtifact struct {
	Artifact

	// Provides additional purpose information of the software artifact.
	SoftwareAdditionalPurposes []SoftwareSoftwarePurpose
	// Provides a place for the SPDX data creator to record acknowledgement text for
	// a software Package, File or Snippet.
	SoftwareAttributionTexts []string
	// A canonical, unique, immutable identifier of the artifact content, that may be
	// used for verifying its identity and/or integrity.
	SoftwareContentIdentifiers SoftwareContentIdentifierList

	// Identifies the text of one or more copyright notices for a software Package,
	// File or Snippet, if any.
	SoftwareCopyrightText string
	// Provides information about the primary purpose of the software artifact.
	SoftwarePrimaryPurpose SoftwareSoftwarePurpose
}

func castSoftwareSoftwareArtifact(o any) *SoftwareSoftwareArtifact {
	if o, ok := o.(AnySoftwareSoftwareArtifact); ok {
		return o.asSoftwareSoftwareArtifact()
	}
	return nil
}

func (o *SoftwareSoftwareArtifact) asSoftwareSoftwareArtifact() *SoftwareSoftwareArtifact {
	return o
}

type AnySoftwareSoftwareArtifact interface {
	AnyArtifact
	asSoftwareSoftwareArtifact() *SoftwareSoftwareArtifact
}

type SoftwareSoftwareArtifactList []AnySoftwareSoftwareArtifact

func (o *SoftwareSoftwareArtifactList) Append(values ...AnySoftwareSoftwareArtifact) {
	*o = append(*o, values...)
}
func (o *SoftwareSoftwareArtifactList) Remove(value AnySoftwareSoftwareArtifact) { remove(o, value) }

func (o *SoftwareSoftwareArtifactList) SoftwareSoftwareArtifactIter() iter.Seq2[AnySoftwareSoftwareArtifact, *SoftwareSoftwareArtifact] {
	return typeIter(*o, castSoftwareSoftwareArtifact)
}
func (o *SoftwareSoftwareArtifactList) SoftwareFileIter() iter.Seq2[AnySoftwareSoftwareArtifact, *SoftwareFile] {
	return typeIter(*o, castSoftwareFile)
}
func (o *SoftwareSoftwareArtifactList) SoftwarePackageIter() iter.Seq2[AnySoftwareSoftwareArtifact, *SoftwarePackage] {
	return typeIter(*o, castSoftwarePackage)
}
func (o *SoftwareSoftwareArtifactList) SoftwareSnippetIter() iter.Seq2[AnySoftwareSoftwareArtifact, *SoftwareSnippet] {
	return typeIter(*o, castSoftwareSnippet)
}
func (o *SoftwareSoftwareArtifactList) AiAIPackageIter() iter.Seq2[AnySoftwareSoftwareArtifact, *AiAIPackage] {
	return typeIter(*o, castAiAIPackage)
}
func (o *SoftwareSoftwareArtifactList) DatasetDatasetPackageIter() iter.Seq2[AnySoftwareSoftwareArtifact, *DatasetDatasetPackage] {
	return typeIter(*o, castDatasetDatasetPackage)
}

// A container for a grouping of SPDX-3.0 content characterizing details
// (provenence, composition, licensing, etc.) about a product.
type Bom struct {
	Bundle
}

func castBom(o any) *Bom {
	if o, ok := o.(AnyBom); ok {
		return o.asBom()
	}
	return nil
}

func (o *Bom) asBom() *Bom {
	return o
}

type AnyBom interface {
	AnyBundle
	asBom() *Bom
}

type BomList []AnyBom

func (o *BomList) Append(values ...AnyBom) { *o = append(*o, values...) }
func (o *BomList) Remove(value AnyBom)     { remove(o, value) }

func (o *BomList) BomIter() iter.Seq2[AnyBom, *Bom] { return typeIter(*o, castBom) }
func (o *BomList) SoftwareSbomIter() iter.Seq2[AnyBom, *SoftwareSbom] {
	return typeIter(*o, castSoftwareSbom)
}

// A license that is not listed on the SPDX License List.
type ExpandedlicensingCustomLicense struct {
	ExpandedlicensingLicense
}

func castExpandedlicensingCustomLicense(o any) *ExpandedlicensingCustomLicense {
	if o, ok := o.(AnyExpandedlicensingCustomLicense); ok {
		return o.asExpandedlicensingCustomLicense()
	}
	return nil
}

func (o *ExpandedlicensingCustomLicense) asExpandedlicensingCustomLicense() *ExpandedlicensingCustomLicense {
	return o
}

type AnyExpandedlicensingCustomLicense interface {
	AnyExpandedlicensingLicense
	asExpandedlicensingCustomLicense() *ExpandedlicensingCustomLicense
}

type ExpandedlicensingCustomLicenseList []AnyExpandedlicensingCustomLicense

func (o *ExpandedlicensingCustomLicenseList) Append(values ...AnyExpandedlicensingCustomLicense) {
	*o = append(*o, values...)
}
func (o *ExpandedlicensingCustomLicenseList) Remove(value AnyExpandedlicensingCustomLicense) {
	remove(o, value)
}

func (o *ExpandedlicensingCustomLicenseList) ExpandedlicensingCustomLicenseIter() iter.Seq2[AnyExpandedlicensingCustomLicense, *ExpandedlicensingCustomLicense] {
	return typeIter(*o, castExpandedlicensingCustomLicense)
}

// Connects a vulnerability and an element designating the element as a product
// affected by the vulnerability.
type SecurityVexAffectedVulnAssessmentRelationship struct {
	SecurityVexVulnAssessmentRelationship

	// Provides advise on how to mitigate or remediate a vulnerability when a VEX product
	// is affected by it.
	SecurityActionStatement string
	// Records the time when a recommended action was communicated in a VEX statement
	// to mitigate a vulnerability.
	SecurityActionStatementTime time.Time
}

func castSecurityVexAffectedVulnAssessmentRelationship(o any) *SecurityVexAffectedVulnAssessmentRelationship {
	if o, ok := o.(AnySecurityVexAffectedVulnAssessmentRelationship); ok {
		return o.asSecurityVexAffectedVulnAssessmentRelationship()
	}
	return nil
}

func (o *SecurityVexAffectedVulnAssessmentRelationship) asSecurityVexAffectedVulnAssessmentRelationship() *SecurityVexAffectedVulnAssessmentRelationship {
	return o
}

type AnySecurityVexAffectedVulnAssessmentRelationship interface {
	AnySecurityVexVulnAssessmentRelationship
	asSecurityVexAffectedVulnAssessmentRelationship() *SecurityVexAffectedVulnAssessmentRelationship
}

type SecurityVexAffectedVulnAssessmentRelationshipList []AnySecurityVexAffectedVulnAssessmentRelationship

func (o *SecurityVexAffectedVulnAssessmentRelationshipList) Append(values ...AnySecurityVexAffectedVulnAssessmentRelationship) {
	*o = append(*o, values...)
}
func (o *SecurityVexAffectedVulnAssessmentRelationshipList) Remove(value AnySecurityVexAffectedVulnAssessmentRelationship) {
	remove(o, value)
}

func (o *SecurityVexAffectedVulnAssessmentRelationshipList) SecurityVexAffectedVulnAssessmentRelationshipIter() iter.Seq2[AnySecurityVexAffectedVulnAssessmentRelationship, *SecurityVexAffectedVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexAffectedVulnAssessmentRelationship)
}

// Links a vulnerability and elements representing products (in the VEX sense) where
// a fix has been applied and are no longer affected.
type SecurityVexFixedVulnAssessmentRelationship struct {
	SecurityVexVulnAssessmentRelationship
}

func castSecurityVexFixedVulnAssessmentRelationship(o any) *SecurityVexFixedVulnAssessmentRelationship {
	if o, ok := o.(AnySecurityVexFixedVulnAssessmentRelationship); ok {
		return o.asSecurityVexFixedVulnAssessmentRelationship()
	}
	return nil
}

func (o *SecurityVexFixedVulnAssessmentRelationship) asSecurityVexFixedVulnAssessmentRelationship() *SecurityVexFixedVulnAssessmentRelationship {
	return o
}

type AnySecurityVexFixedVulnAssessmentRelationship interface {
	AnySecurityVexVulnAssessmentRelationship
	asSecurityVexFixedVulnAssessmentRelationship() *SecurityVexFixedVulnAssessmentRelationship
}

type SecurityVexFixedVulnAssessmentRelationshipList []AnySecurityVexFixedVulnAssessmentRelationship

func (o *SecurityVexFixedVulnAssessmentRelationshipList) Append(values ...AnySecurityVexFixedVulnAssessmentRelationship) {
	*o = append(*o, values...)
}
func (o *SecurityVexFixedVulnAssessmentRelationshipList) Remove(value AnySecurityVexFixedVulnAssessmentRelationship) {
	remove(o, value)
}

func (o *SecurityVexFixedVulnAssessmentRelationshipList) SecurityVexFixedVulnAssessmentRelationshipIter() iter.Seq2[AnySecurityVexFixedVulnAssessmentRelationship, *SecurityVexFixedVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexFixedVulnAssessmentRelationship)
}

// Links a vulnerability and one or more elements designating the latter as products
// not affected by the vulnerability.
type SecurityVexNotAffectedVulnAssessmentRelationship struct {
	SecurityVexVulnAssessmentRelationship

	// Explains why a VEX product is not affected by a vulnerability. It is an
	// alternative in VexNotAffectedVulnAssessmentRelationship to the machine-readable
	// justification label.
	SecurityImpactStatement string
	// Timestamp of impact statement.
	SecurityImpactStatementTime time.Time
	// Impact justification label to be used when linking a vulnerability to an element
	// representing a VEX product with a VexNotAffectedVulnAssessmentRelationship
	// relationship.
	SecurityJustificationType SecurityVexJustificationType
}

func castSecurityVexNotAffectedVulnAssessmentRelationship(o any) *SecurityVexNotAffectedVulnAssessmentRelationship {
	if o, ok := o.(AnySecurityVexNotAffectedVulnAssessmentRelationship); ok {
		return o.asSecurityVexNotAffectedVulnAssessmentRelationship()
	}
	return nil
}

func (o *SecurityVexNotAffectedVulnAssessmentRelationship) asSecurityVexNotAffectedVulnAssessmentRelationship() *SecurityVexNotAffectedVulnAssessmentRelationship {
	return o
}

type AnySecurityVexNotAffectedVulnAssessmentRelationship interface {
	AnySecurityVexVulnAssessmentRelationship
	asSecurityVexNotAffectedVulnAssessmentRelationship() *SecurityVexNotAffectedVulnAssessmentRelationship
}

type SecurityVexNotAffectedVulnAssessmentRelationshipList []AnySecurityVexNotAffectedVulnAssessmentRelationship

func (o *SecurityVexNotAffectedVulnAssessmentRelationshipList) Append(values ...AnySecurityVexNotAffectedVulnAssessmentRelationship) {
	*o = append(*o, values...)
}
func (o *SecurityVexNotAffectedVulnAssessmentRelationshipList) Remove(value AnySecurityVexNotAffectedVulnAssessmentRelationship) {
	remove(o, value)
}

func (o *SecurityVexNotAffectedVulnAssessmentRelationshipList) SecurityVexNotAffectedVulnAssessmentRelationshipIter() iter.Seq2[AnySecurityVexNotAffectedVulnAssessmentRelationship, *SecurityVexNotAffectedVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexNotAffectedVulnAssessmentRelationship)
}

// Designates elements as products where the impact of a vulnerability is being
// investigated.
type SecurityVexUnderInvestigationVulnAssessmentRelationship struct {
	SecurityVexVulnAssessmentRelationship
}

func castSecurityVexUnderInvestigationVulnAssessmentRelationship(o any) *SecurityVexUnderInvestigationVulnAssessmentRelationship {
	if o, ok := o.(AnySecurityVexUnderInvestigationVulnAssessmentRelationship); ok {
		return o.asSecurityVexUnderInvestigationVulnAssessmentRelationship()
	}
	return nil
}

func (o *SecurityVexUnderInvestigationVulnAssessmentRelationship) asSecurityVexUnderInvestigationVulnAssessmentRelationship() *SecurityVexUnderInvestigationVulnAssessmentRelationship {
	return o
}

type AnySecurityVexUnderInvestigationVulnAssessmentRelationship interface {
	AnySecurityVexVulnAssessmentRelationship
	asSecurityVexUnderInvestigationVulnAssessmentRelationship() *SecurityVexUnderInvestigationVulnAssessmentRelationship
}

type SecurityVexUnderInvestigationVulnAssessmentRelationshipList []AnySecurityVexUnderInvestigationVulnAssessmentRelationship

func (o *SecurityVexUnderInvestigationVulnAssessmentRelationshipList) Append(values ...AnySecurityVexUnderInvestigationVulnAssessmentRelationship) {
	*o = append(*o, values...)
}
func (o *SecurityVexUnderInvestigationVulnAssessmentRelationshipList) Remove(value AnySecurityVexUnderInvestigationVulnAssessmentRelationship) {
	remove(o, value)
}

func (o *SecurityVexUnderInvestigationVulnAssessmentRelationshipList) SecurityVexUnderInvestigationVulnAssessmentRelationshipIter() iter.Seq2[AnySecurityVexUnderInvestigationVulnAssessmentRelationship, *SecurityVexUnderInvestigationVulnAssessmentRelationship] {
	return typeIter(*o, castSecurityVexUnderInvestigationVulnAssessmentRelationship)
}

// Refers to any object that stores content on a computer.
type SoftwareFile struct {
	SoftwareSoftwareArtifact

	// Provides information about the content type of an Element or a Property.
	ContentType string
	// Describes if a given file is a directory or non-directory kind of file.
	SoftwareFileKind SoftwareFileKindType
}

func castSoftwareFile(o any) *SoftwareFile {
	if o, ok := o.(AnySoftwareFile); ok {
		return o.asSoftwareFile()
	}
	return nil
}

func (o *SoftwareFile) asSoftwareFile() *SoftwareFile {
	return o
}

type AnySoftwareFile interface {
	AnySoftwareSoftwareArtifact
	asSoftwareFile() *SoftwareFile
}

type SoftwareFileList []AnySoftwareFile

func (o *SoftwareFileList) Append(values ...AnySoftwareFile) { *o = append(*o, values...) }
func (o *SoftwareFileList) Remove(value AnySoftwareFile)     { remove(o, value) }

func (o *SoftwareFileList) SoftwareFileIter() iter.Seq2[AnySoftwareFile, *SoftwareFile] {
	return typeIter(*o, castSoftwareFile)
}

// Refers to any unit of content that can be associated with a distribution of
// software.
type SoftwarePackage struct {
	SoftwareSoftwareArtifact

	// Identifies the download Uniform Resource Identifier for the package at the time
	// that the document was created.
	SoftwareDownloadLocation string
	// A place for the SPDX document creator to record a website that serves as the
	// package's home page.
	SoftwareHomePage string
	// Provides a place for the SPDX data creator to record the package URL string
	// (in accordance with the Package URL specification) for a software Package.
	SoftwarePackageUrl string
	// Identify the version of a package.
	SoftwarePackageVersion string
	// Records any relevant background information or additional comments
	// about the origin of the package.
	SoftwareSourceInfo string
}

func castSoftwarePackage(o any) *SoftwarePackage {
	if o, ok := o.(AnySoftwarePackage); ok {
		return o.asSoftwarePackage()
	}
	return nil
}

func (o *SoftwarePackage) asSoftwarePackage() *SoftwarePackage {
	return o
}

type AnySoftwarePackage interface {
	AnySoftwareSoftwareArtifact
	asSoftwarePackage() *SoftwarePackage
}

type SoftwarePackageList []AnySoftwarePackage

func (o *SoftwarePackageList) Append(values ...AnySoftwarePackage) { *o = append(*o, values...) }
func (o *SoftwarePackageList) Remove(value AnySoftwarePackage)     { remove(o, value) }

func (o *SoftwarePackageList) SoftwarePackageIter() iter.Seq2[AnySoftwarePackage, *SoftwarePackage] {
	return typeIter(*o, castSoftwarePackage)
}
func (o *SoftwarePackageList) AiAIPackageIter() iter.Seq2[AnySoftwarePackage, *AiAIPackage] {
	return typeIter(*o, castAiAIPackage)
}
func (o *SoftwarePackageList) DatasetDatasetPackageIter() iter.Seq2[AnySoftwarePackage, *DatasetDatasetPackage] {
	return typeIter(*o, castDatasetDatasetPackage)
}

// A collection of SPDX Elements describing a single package.
type SoftwareSbom struct {
	Bom

	// Provides information about the type of an SBOM.
	SoftwareSbomTypes []SoftwareSbomType
}

func castSoftwareSbom(o any) *SoftwareSbom {
	if o, ok := o.(AnySoftwareSbom); ok {
		return o.asSoftwareSbom()
	}
	return nil
}

func (o *SoftwareSbom) asSoftwareSbom() *SoftwareSbom {
	return o
}

type AnySoftwareSbom interface {
	AnyBom
	asSoftwareSbom() *SoftwareSbom
}

type SoftwareSbomList []AnySoftwareSbom

func (o *SoftwareSbomList) Append(values ...AnySoftwareSbom) { *o = append(*o, values...) }
func (o *SoftwareSbomList) Remove(value AnySoftwareSbom)     { remove(o, value) }

func (o *SoftwareSbomList) SoftwareSbomIter() iter.Seq2[AnySoftwareSbom, *SoftwareSbom] {
	return typeIter(*o, castSoftwareSbom)
}

// Describes a certain part of a file.
type SoftwareSnippet struct {
	SoftwareSoftwareArtifact

	// Defines the byte range in the original host file that the snippet information
	// applies to.
	SoftwareByteRange AnyPositiveIntegerRange

	// Defines the line range in the original host file that the snippet information
	// applies to.
	SoftwareLineRange AnyPositiveIntegerRange

	// Defines the original host file that the snippet information applies to.
	SoftwareSnippetFromFile AnySoftwareFile
}

func castSoftwareSnippet(o any) *SoftwareSnippet {
	if o, ok := o.(AnySoftwareSnippet); ok {
		return o.asSoftwareSnippet()
	}
	return nil
}

func (o *SoftwareSnippet) asSoftwareSnippet() *SoftwareSnippet {
	return o
}

type AnySoftwareSnippet interface {
	AnySoftwareSoftwareArtifact
	asSoftwareSnippet() *SoftwareSnippet
}

type SoftwareSnippetList []AnySoftwareSnippet

func (o *SoftwareSnippetList) Append(values ...AnySoftwareSnippet) { *o = append(*o, values...) }
func (o *SoftwareSnippetList) Remove(value AnySoftwareSnippet)     { remove(o, value) }

func (o *SoftwareSnippetList) SoftwareSnippetIter() iter.Seq2[AnySoftwareSnippet, *SoftwareSnippet] {
	return typeIter(*o, castSoftwareSnippet)
}

// Specifies an AI package and its associated information.
type AiAIPackage struct {
	SoftwarePackage

	// Indicates whether the system can perform a decision or action without human
	// involvement or guidance.
	AiAutonomyType PresenceType
	// Captures the domain in which the AI package can be used.
	AiDomains []string
	// Indicates the amount of energy consumption incurred by an AI model.
	AiEnergyConsumption AnyAiEnergyConsumption

	// Records a hyperparameter used to build the AI model contained in the AI
	// package.
	AiHyperparameters DictionaryEntryList

	// Provides relevant information about the AI software, not including the model
	// description.
	AiInformationAboutApplication string
	// Describes relevant information about different steps of the training process.
	AiInformationAboutTraining string
	// Captures a limitation of the AI software.
	AiLimitation string
	// Records the measurement of prediction quality of the AI model.
	AiMetrics DictionaryEntryList

	// Captures the threshold that was used for computation of a metric described in
	// the metric field.
	AiMetricDecisionThresholds DictionaryEntryList

	// Describes all the preprocessing steps applied to the training data before the
	// model training.
	AiModelDataPreprocessings []string
	// Describes methods that can be used to explain the results from the AI model.
	AiModelExplainabilitys []string
	// Records the results of general safety risk assessment of the AI system.
	AiSafetyRiskAssessment AiSafetyRiskAssessmentType
	// Captures a standard that is being complied with.
	AiStandardCompliances []string
	// Records the type of the model used in the AI software.
	AiTypeOfModels []string
	// Records if sensitive personal information is used during model training or
	// could be used during the inference.
	AiUseSensitivePersonalInformation PresenceType
}

func castAiAIPackage(o any) *AiAIPackage {
	if o, ok := o.(AnyAiAIPackage); ok {
		return o.asAiAIPackage()
	}
	return nil
}

func (o *AiAIPackage) asAiAIPackage() *AiAIPackage {
	return o
}

type AnyAiAIPackage interface {
	AnySoftwarePackage
	asAiAIPackage() *AiAIPackage
}

type AiAIPackageList []AnyAiAIPackage

func (o *AiAIPackageList) Append(values ...AnyAiAIPackage) { *o = append(*o, values...) }
func (o *AiAIPackageList) Remove(value AnyAiAIPackage)     { remove(o, value) }

func (o *AiAIPackageList) AiAIPackageIter() iter.Seq2[AnyAiAIPackage, *AiAIPackage] {
	return typeIter(*o, castAiAIPackage)
}

// Specifies a data package and its associated information.
type DatasetDatasetPackage struct {
	SoftwarePackage

	// Describes the anonymization methods used.
	DatasetAnonymizationMethodUseds []string
	// Describes the confidentiality level of the data points contained in the dataset.
	DatasetConfidentialityLevel DatasetConfidentialityLevelType
	// Describes how the dataset was collected.
	DatasetDataCollectionProcess string
	// Describes the preprocessing steps that were applied to the raw data to create the given dataset.
	DatasetDataPreprocessings []string
	// The field describes the availability of a dataset.
	DatasetDatasetAvailability DatasetDatasetAvailabilityType
	// Describes potentially noisy elements of the dataset.
	DatasetDatasetNoise string
	// Captures the size of the dataset.
	DatasetDatasetSize int
	// Describes the type of the given dataset.
	DatasetDatasetTypes []DatasetDatasetType
	// Describes a mechanism to update the dataset.
	DatasetDatasetUpdateMechanism string
	// Describes if any sensitive personal information is present in the dataset.
	DatasetHasSensitivePersonalInformation PresenceType
	// Describes what the given dataset should be used for.
	DatasetIntendedUse string
	// Records the biases that the dataset is known to encompass.
	DatasetKnownBias []string
	// Describes a sensor used for collecting the data.
	DatasetSensors DictionaryEntryList
}

func castDatasetDatasetPackage(o any) *DatasetDatasetPackage {
	if o, ok := o.(AnyDatasetDatasetPackage); ok {
		return o.asDatasetDatasetPackage()
	}
	return nil
}

func (o *DatasetDatasetPackage) asDatasetDatasetPackage() *DatasetDatasetPackage {
	return o
}

type AnyDatasetDatasetPackage interface {
	AnySoftwarePackage
	asDatasetDatasetPackage() *DatasetDatasetPackage
}

type DatasetDatasetPackageList []AnyDatasetDatasetPackage

func (o *DatasetDatasetPackageList) Append(values ...AnyDatasetDatasetPackage) {
	*o = append(*o, values...)
}
func (o *DatasetDatasetPackageList) Remove(value AnyDatasetDatasetPackage) { remove(o, value) }

func (o *DatasetDatasetPackageList) DatasetDatasetPackageIter() iter.Seq2[AnyDatasetDatasetPackage, *DatasetDatasetPackage] {
	return typeIter(*o, castDatasetDatasetPackage)
}

type ExternalIRI struct {
	iri string
}

func NewExternalIRI(iri string) *ExternalIRI {
	return &ExternalIRI{iri: iri}
}

func (o *ExternalIRI) asAiEnergyConsumption() *AiEnergyConsumption                       { return nil }
func (o *ExternalIRI) asAiEnergyConsumptionDescription() *AiEnergyConsumptionDescription { return nil }
func (o *ExternalIRI) asCreationInfo() *CreationInfo                                     { return nil }
func (o *ExternalIRI) asDictionaryEntry() *DictionaryEntry                               { return nil }
func (o *ExternalIRI) asElement() *Element                                               { return nil }
func (o *ExternalIRI) asElementCollection() *ElementCollection                           { return nil }
func (o *ExternalIRI) asExternalIdentifier() *ExternalIdentifier                         { return nil }
func (o *ExternalIRI) asExternalMap() *ExternalMap                                       { return nil }
func (o *ExternalIRI) asExternalRef() *ExternalRef                                       { return nil }
func (o *ExternalIRI) asIndividualElement() *IndividualElement                           { return nil }
func (o *ExternalIRI) asIntegrityMethod() *IntegrityMethod                               { return nil }
func (o *ExternalIRI) asNamespaceMap() *NamespaceMap                                     { return nil }
func (o *ExternalIRI) asPackageVerificationCode() *PackageVerificationCode               { return nil }
func (o *ExternalIRI) asPositiveIntegerRange() *PositiveIntegerRange                     { return nil }
func (o *ExternalIRI) asRelationship() *Relationship                                     { return nil }
func (o *ExternalIRI) asSpdxDocument() *SpdxDocument                                     { return nil }
func (o *ExternalIRI) asTool() *Tool                                                     { return nil }
func (o *ExternalIRI) asExpandedlicensingLicenseAddition() *ExpandedlicensingLicenseAddition {
	return nil
}
func (o *ExternalIRI) asExpandedlicensingListedLicenseException() *ExpandedlicensingListedLicenseException {
	return nil
}
func (o *ExternalIRI) asExtensionCdxPropertyEntry() *ExtensionCdxPropertyEntry { return nil }
func (o *ExternalIRI) asExtensionExtension() *ExtensionExtension               { return nil }
func (o *ExternalIRI) asSecurityVulnAssessmentRelationship() *SecurityVulnAssessmentRelationship {
	return nil
}
func (o *ExternalIRI) asSimplelicensingAnyLicenseInfo() *SimplelicensingAnyLicenseInfo { return nil }
func (o *ExternalIRI) asSimplelicensingLicenseExpression() *SimplelicensingLicenseExpression {
	return nil
}
func (o *ExternalIRI) asSimplelicensingSimpleLicensingText() *SimplelicensingSimpleLicensingText {
	return nil
}
func (o *ExternalIRI) asSoftwareContentIdentifier() *SoftwareContentIdentifier     { return nil }
func (o *ExternalIRI) asBuildBuild() *BuildBuild                                   { return nil }
func (o *ExternalIRI) asAgent() *Agent                                             { return nil }
func (o *ExternalIRI) asAnnotation() *Annotation                                   { return nil }
func (o *ExternalIRI) asArtifact() *Artifact                                       { return nil }
func (o *ExternalIRI) asBundle() *Bundle                                           { return nil }
func (o *ExternalIRI) asHash() *Hash                                               { return nil }
func (o *ExternalIRI) asLifecycleScopedRelationship() *LifecycleScopedRelationship { return nil }
func (o *ExternalIRI) asOrganization() *Organization                               { return nil }
func (o *ExternalIRI) asPerson() *Person                                           { return nil }
func (o *ExternalIRI) asSoftwareAgent() *SoftwareAgent                             { return nil }
func (o *ExternalIRI) asExpandedlicensingConjunctiveLicenseSet() *ExpandedlicensingConjunctiveLicenseSet {
	return nil
}
func (o *ExternalIRI) asExpandedlicensingCustomLicenseAddition() *ExpandedlicensingCustomLicenseAddition {
	return nil
}
func (o *ExternalIRI) asExpandedlicensingDisjunctiveLicenseSet() *ExpandedlicensingDisjunctiveLicenseSet {
	return nil
}
func (o *ExternalIRI) asExpandedlicensingExtendableLicense() *ExpandedlicensingExtendableLicense {
	return nil
}
func (o *ExternalIRI) asExpandedlicensingIndividualLicensingInfo() *ExpandedlicensingIndividualLicensingInfo {
	return nil
}
func (o *ExternalIRI) asExpandedlicensingLicense() *ExpandedlicensingLicense             { return nil }
func (o *ExternalIRI) asExpandedlicensingListedLicense() *ExpandedlicensingListedLicense { return nil }
func (o *ExternalIRI) asExpandedlicensingOrLaterOperator() *ExpandedlicensingOrLaterOperator {
	return nil
}
func (o *ExternalIRI) asExpandedlicensingWithAdditionOperator() *ExpandedlicensingWithAdditionOperator {
	return nil
}
func (o *ExternalIRI) asExtensionCdxPropertiesExtension() *ExtensionCdxPropertiesExtension {
	return nil
}
func (o *ExternalIRI) asSecurityCvssV2VulnAssessmentRelationship() *SecurityCvssV2VulnAssessmentRelationship {
	return nil
}
func (o *ExternalIRI) asSecurityCvssV3VulnAssessmentRelationship() *SecurityCvssV3VulnAssessmentRelationship {
	return nil
}
func (o *ExternalIRI) asSecurityCvssV4VulnAssessmentRelationship() *SecurityCvssV4VulnAssessmentRelationship {
	return nil
}
func (o *ExternalIRI) asSecurityEpssVulnAssessmentRelationship() *SecurityEpssVulnAssessmentRelationship {
	return nil
}
func (o *ExternalIRI) asSecurityExploitCatalogVulnAssessmentRelationship() *SecurityExploitCatalogVulnAssessmentRelationship {
	return nil
}
func (o *ExternalIRI) asSecuritySsvcVulnAssessmentRelationship() *SecuritySsvcVulnAssessmentRelationship {
	return nil
}
func (o *ExternalIRI) asSecurityVexVulnAssessmentRelationship() *SecurityVexVulnAssessmentRelationship {
	return nil
}
func (o *ExternalIRI) asSecurityVulnerability() *SecurityVulnerability                   { return nil }
func (o *ExternalIRI) asSoftwareSoftwareArtifact() *SoftwareSoftwareArtifact             { return nil }
func (o *ExternalIRI) asBom() *Bom                                                       { return nil }
func (o *ExternalIRI) asExpandedlicensingCustomLicense() *ExpandedlicensingCustomLicense { return nil }
func (o *ExternalIRI) asSecurityVexAffectedVulnAssessmentRelationship() *SecurityVexAffectedVulnAssessmentRelationship {
	return nil
}
func (o *ExternalIRI) asSecurityVexFixedVulnAssessmentRelationship() *SecurityVexFixedVulnAssessmentRelationship {
	return nil
}
func (o *ExternalIRI) asSecurityVexNotAffectedVulnAssessmentRelationship() *SecurityVexNotAffectedVulnAssessmentRelationship {
	return nil
}
func (o *ExternalIRI) asSecurityVexUnderInvestigationVulnAssessmentRelationship() *SecurityVexUnderInvestigationVulnAssessmentRelationship {
	return nil
}
func (o *ExternalIRI) asSoftwareFile() *SoftwareFile                   { return nil }
func (o *ExternalIRI) asSoftwarePackage() *SoftwarePackage             { return nil }
func (o *ExternalIRI) asSoftwareSbom() *SoftwareSbom                   { return nil }
func (o *ExternalIRI) asSoftwareSnippet() *SoftwareSnippet             { return nil }
func (o *ExternalIRI) asAiAIPackage() *AiAIPackage                     { return nil }
func (o *ExternalIRI) asDatasetDatasetPackage() *DatasetDatasetPackage { return nil }

func cast[T any](value any) *T {
	var t T
	switch any(t).(type) {
	case AiEnergyConsumption:
		if v, ok := any(castAiEnergyConsumption(value)).(*T); ok {
			return v
		}
	case AiEnergyConsumptionDescription:
		if v, ok := any(castAiEnergyConsumptionDescription(value)).(*T); ok {
			return v
		}
	case CreationInfo:
		if v, ok := any(castCreationInfo(value)).(*T); ok {
			return v
		}
	case DictionaryEntry:
		if v, ok := any(castDictionaryEntry(value)).(*T); ok {
			return v
		}
	case Element:
		if v, ok := any(castElement(value)).(*T); ok {
			return v
		}
	case ElementCollection:
		if v, ok := any(castElementCollection(value)).(*T); ok {
			return v
		}
	case ExternalIdentifier:
		if v, ok := any(castExternalIdentifier(value)).(*T); ok {
			return v
		}
	case ExternalMap:
		if v, ok := any(castExternalMap(value)).(*T); ok {
			return v
		}
	case ExternalRef:
		if v, ok := any(castExternalRef(value)).(*T); ok {
			return v
		}
	case IndividualElement:
		if v, ok := any(castIndividualElement(value)).(*T); ok {
			return v
		}
	case IntegrityMethod:
		if v, ok := any(castIntegrityMethod(value)).(*T); ok {
			return v
		}
	case NamespaceMap:
		if v, ok := any(castNamespaceMap(value)).(*T); ok {
			return v
		}
	case PackageVerificationCode:
		if v, ok := any(castPackageVerificationCode(value)).(*T); ok {
			return v
		}
	case PositiveIntegerRange:
		if v, ok := any(castPositiveIntegerRange(value)).(*T); ok {
			return v
		}
	case Relationship:
		if v, ok := any(castRelationship(value)).(*T); ok {
			return v
		}
	case SpdxDocument:
		if v, ok := any(castSpdxDocument(value)).(*T); ok {
			return v
		}
	case Tool:
		if v, ok := any(castTool(value)).(*T); ok {
			return v
		}
	case ExpandedlicensingLicenseAddition:
		if v, ok := any(castExpandedlicensingLicenseAddition(value)).(*T); ok {
			return v
		}
	case ExpandedlicensingListedLicenseException:
		if v, ok := any(castExpandedlicensingListedLicenseException(value)).(*T); ok {
			return v
		}
	case ExtensionCdxPropertyEntry:
		if v, ok := any(castExtensionCdxPropertyEntry(value)).(*T); ok {
			return v
		}
	case ExtensionExtension:
		if v, ok := any(castExtensionExtension(value)).(*T); ok {
			return v
		}
	case SecurityVulnAssessmentRelationship:
		if v, ok := any(castSecurityVulnAssessmentRelationship(value)).(*T); ok {
			return v
		}
	case SimplelicensingAnyLicenseInfo:
		if v, ok := any(castSimplelicensingAnyLicenseInfo(value)).(*T); ok {
			return v
		}
	case SimplelicensingLicenseExpression:
		if v, ok := any(castSimplelicensingLicenseExpression(value)).(*T); ok {
			return v
		}
	case SimplelicensingSimpleLicensingText:
		if v, ok := any(castSimplelicensingSimpleLicensingText(value)).(*T); ok {
			return v
		}
	case SoftwareContentIdentifier:
		if v, ok := any(castSoftwareContentIdentifier(value)).(*T); ok {
			return v
		}
	case BuildBuild:
		if v, ok := any(castBuildBuild(value)).(*T); ok {
			return v
		}
	case Agent:
		if v, ok := any(castAgent(value)).(*T); ok {
			return v
		}
	case Annotation:
		if v, ok := any(castAnnotation(value)).(*T); ok {
			return v
		}
	case Artifact:
		if v, ok := any(castArtifact(value)).(*T); ok {
			return v
		}
	case Bundle:
		if v, ok := any(castBundle(value)).(*T); ok {
			return v
		}
	case Hash:
		if v, ok := any(castHash(value)).(*T); ok {
			return v
		}
	case LifecycleScopedRelationship:
		if v, ok := any(castLifecycleScopedRelationship(value)).(*T); ok {
			return v
		}
	case Organization:
		if v, ok := any(castOrganization(value)).(*T); ok {
			return v
		}
	case Person:
		if v, ok := any(castPerson(value)).(*T); ok {
			return v
		}
	case SoftwareAgent:
		if v, ok := any(castSoftwareAgent(value)).(*T); ok {
			return v
		}
	case ExpandedlicensingConjunctiveLicenseSet:
		if v, ok := any(castExpandedlicensingConjunctiveLicenseSet(value)).(*T); ok {
			return v
		}
	case ExpandedlicensingCustomLicenseAddition:
		if v, ok := any(castExpandedlicensingCustomLicenseAddition(value)).(*T); ok {
			return v
		}
	case ExpandedlicensingDisjunctiveLicenseSet:
		if v, ok := any(castExpandedlicensingDisjunctiveLicenseSet(value)).(*T); ok {
			return v
		}
	case ExpandedlicensingExtendableLicense:
		if v, ok := any(castExpandedlicensingExtendableLicense(value)).(*T); ok {
			return v
		}
	case ExpandedlicensingIndividualLicensingInfo:
		if v, ok := any(castExpandedlicensingIndividualLicensingInfo(value)).(*T); ok {
			return v
		}
	case ExpandedlicensingLicense:
		if v, ok := any(castExpandedlicensingLicense(value)).(*T); ok {
			return v
		}
	case ExpandedlicensingListedLicense:
		if v, ok := any(castExpandedlicensingListedLicense(value)).(*T); ok {
			return v
		}
	case ExpandedlicensingOrLaterOperator:
		if v, ok := any(castExpandedlicensingOrLaterOperator(value)).(*T); ok {
			return v
		}
	case ExpandedlicensingWithAdditionOperator:
		if v, ok := any(castExpandedlicensingWithAdditionOperator(value)).(*T); ok {
			return v
		}
	case ExtensionCdxPropertiesExtension:
		if v, ok := any(castExtensionCdxPropertiesExtension(value)).(*T); ok {
			return v
		}
	case SecurityCvssV2VulnAssessmentRelationship:
		if v, ok := any(castSecurityCvssV2VulnAssessmentRelationship(value)).(*T); ok {
			return v
		}
	case SecurityCvssV3VulnAssessmentRelationship:
		if v, ok := any(castSecurityCvssV3VulnAssessmentRelationship(value)).(*T); ok {
			return v
		}
	case SecurityCvssV4VulnAssessmentRelationship:
		if v, ok := any(castSecurityCvssV4VulnAssessmentRelationship(value)).(*T); ok {
			return v
		}
	case SecurityEpssVulnAssessmentRelationship:
		if v, ok := any(castSecurityEpssVulnAssessmentRelationship(value)).(*T); ok {
			return v
		}
	case SecurityExploitCatalogVulnAssessmentRelationship:
		if v, ok := any(castSecurityExploitCatalogVulnAssessmentRelationship(value)).(*T); ok {
			return v
		}
	case SecuritySsvcVulnAssessmentRelationship:
		if v, ok := any(castSecuritySsvcVulnAssessmentRelationship(value)).(*T); ok {
			return v
		}
	case SecurityVexVulnAssessmentRelationship:
		if v, ok := any(castSecurityVexVulnAssessmentRelationship(value)).(*T); ok {
			return v
		}
	case SecurityVulnerability:
		if v, ok := any(castSecurityVulnerability(value)).(*T); ok {
			return v
		}
	case SoftwareSoftwareArtifact:
		if v, ok := any(castSoftwareSoftwareArtifact(value)).(*T); ok {
			return v
		}
	case Bom:
		if v, ok := any(castBom(value)).(*T); ok {
			return v
		}
	case ExpandedlicensingCustomLicense:
		if v, ok := any(castExpandedlicensingCustomLicense(value)).(*T); ok {
			return v
		}
	case SecurityVexAffectedVulnAssessmentRelationship:
		if v, ok := any(castSecurityVexAffectedVulnAssessmentRelationship(value)).(*T); ok {
			return v
		}
	case SecurityVexFixedVulnAssessmentRelationship:
		if v, ok := any(castSecurityVexFixedVulnAssessmentRelationship(value)).(*T); ok {
			return v
		}
	case SecurityVexNotAffectedVulnAssessmentRelationship:
		if v, ok := any(castSecurityVexNotAffectedVulnAssessmentRelationship(value)).(*T); ok {
			return v
		}
	case SecurityVexUnderInvestigationVulnAssessmentRelationship:
		if v, ok := any(castSecurityVexUnderInvestigationVulnAssessmentRelationship(value)).(*T); ok {
			return v
		}
	case SoftwareFile:
		if v, ok := any(castSoftwareFile(value)).(*T); ok {
			return v
		}
	case SoftwarePackage:
		if v, ok := any(castSoftwarePackage(value)).(*T); ok {
			return v
		}
	case SoftwareSbom:
		if v, ok := any(castSoftwareSbom(value)).(*T); ok {
			return v
		}
	case SoftwareSnippet:
		if v, ok := any(castSoftwareSnippet(value)).(*T); ok {
			return v
		}
	case AiAIPackage:
		if v, ok := any(castAiAIPackage(value)).(*T); ok {
			return v
		}
	case DatasetDatasetPackage:
		if v, ok := any(castDatasetDatasetPackage(value)).(*T); ok {
			return v
		}
	}
	panic("invalid type cast, unknown type: " + reflect.TypeOf(t).String())
}

func As[T any](value any, f func(v *T)) {
	v := cast[T](value)
	if v != nil {
		f(v)
	}
}
