// This file was automatically generated by __main__.py. DO NOT MANUALLY MODIFY IT
//
// SPDX-License-Identifier: 0BSD

package v3_0

import (
	"fmt"
	"slices"
	"strconv"
	"strings"
)

type ValidationError struct {
	Path []string
	Err  error
}

func (v ValidationError) String() string {
	return strings.Join(v.Path, ".") + ": " + v.Err.Error()
}

func (v ValidationError) Error() string {
	return v.String()
}

func newValidationError(path []string, err error) ValidationError {
	return ValidationError{
		Path: path,
		Err:  err,
	}
}

type validator interface {
	Validate(visited map[any]struct{}, path ...string) []ValidationError
}

func validateInValues(path []string, value string, valid ...string) []ValidationError {
	if slices.Contains(valid, value) {
		return nil
	}
	return []ValidationError{newValidationError(path, fmt.Errorf("invalid value: '%v', expected: %v", value, valid))}
}

func (o *AiEnergyConsumption) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	for i, v := range o.AiFinetuningEnergyConsumptions {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "AiFinetuningEnergyConsumptions", strconv.Itoa(i))...)...)
		}
	}

	for i, v := range o.AiInferenceEnergyConsumptions {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "AiInferenceEnergyConsumptions", strconv.Itoa(i))...)...)
		}
	}

	for i, v := range o.AiTrainingEnergyConsumptions {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "AiTrainingEnergyConsumptions", strconv.Itoa(i))...)...)
		}
	}

	return errs
}

func (o *AiEnergyConsumptionDescription) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	// TODO: check for required

	if o.AiEnergyUnit.ID == "" {
		errs = append(errs, newValidationError(append(path, "AiEnergyUnit"), fmt.Errorf("required")))
	}
	errs = append(errs, o.AiEnergyUnit.Validate(visited, append(path, "AiEnergyUnit")...)...)

	return errs
}

func (o *AiEnergyUnitType) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, AiEnergyUnitType_KilowattHour.ID, AiEnergyUnitType_Megajoule.ID, AiEnergyUnitType_Other.ID)...)

	return errs
}

func (o *AiSafetyRiskAssessmentType) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, AiSafetyRiskAssessmentType_High.ID, AiSafetyRiskAssessmentType_Low.ID, AiSafetyRiskAssessmentType_Medium.ID, AiSafetyRiskAssessmentType_Serious.ID)...)

	return errs
}

func (o *AnnotationType) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, AnnotationType_Other.ID, AnnotationType_Review.ID)...)

	return errs
}

func (o *CreationInfo) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	// TODO: check for required

	// TODO: check for required

	for i, v := range o.CreatedBys {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "CreatedBys", strconv.Itoa(i))...)...)
		}
	}

	for i, v := range o.CreatedUsings {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "CreatedUsings", strconv.Itoa(i))...)...)
		}
	}

	// TODO: check for required
	return errs
}

func (o *DictionaryEntry) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	// TODO: check for required

	// TODO: check for required
	return errs
}

func (o *Element) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	// TODO: check for required

	if v, ok := o.CreationInfo.(validator); ok {
		errs = append(errs, v.Validate(visited, append(path, "CreationInfo")...)...)
	}

	// TODO: check for required

	for i, v := range o.Extensions {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "Extensions", strconv.Itoa(i))...)...)
		}
	}

	for i, v := range o.ExternalIdentifiers {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "ExternalIdentifiers", strconv.Itoa(i))...)...)
		}
	}

	for i, v := range o.ExternalRefs {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "ExternalRefs", strconv.Itoa(i))...)...)
		}
	}

	// TODO: check for required

	// TODO: check for required

	for i, v := range o.VerifiedUsings {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "VerifiedUsings", strconv.Itoa(i))...)...)
		}
	}

	return errs
}

func (o *ElementCollection) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.Element.Validate(visited, path...)...)

	for i, v := range o.Elements {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "Elements", strconv.Itoa(i))...)...)
		}
	}

	for _, v := range o.ProfileConformances {
		errs = append(errs, v.Validate(visited, append(path, "ProfileConformances")...)...)
	}

	for i, v := range o.RootElements {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "RootElements", strconv.Itoa(i))...)...)
		}
	}

	return errs
}

func (o *ExternalIdentifier) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	// TODO: check for required

	if o.ExternalIdentifierType.ID == "" {
		errs = append(errs, newValidationError(append(path, "ExternalIdentifierType"), fmt.Errorf("required")))
	}
	errs = append(errs, o.ExternalIdentifierType.Validate(visited, append(path, "ExternalIdentifierType")...)...)

	// TODO: check for required

	// TODO: check for required/min/max/etc.

	// TODO: check for required
	return errs
}

func (o *ExternalIdentifierType) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, ExternalIdentifierType_Cpe22.ID, ExternalIdentifierType_Cpe23.ID, ExternalIdentifierType_Cve.ID, ExternalIdentifierType_Email.ID, ExternalIdentifierType_Gitoid.ID, ExternalIdentifierType_Other.ID, ExternalIdentifierType_PackageUrl.ID, ExternalIdentifierType_SecurityOther.ID, ExternalIdentifierType_Swhid.ID, ExternalIdentifierType_Swid.ID, ExternalIdentifierType_UrlScheme.ID)...)

	return errs
}

func (o *ExternalMap) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	if v, ok := o.DefiningArtifact.(validator); ok {
		errs = append(errs, v.Validate(visited, append(path, "DefiningArtifact")...)...)
	}

	// TODO: check for required

	// TODO: check for required

	for i, v := range o.VerifiedUsings {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "VerifiedUsings", strconv.Itoa(i))...)...)
		}
	}

	return errs
}

func (o *ExternalRef) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	// TODO: check for required

	// TODO: check for required

	errs = append(errs, o.ExternalRefType.Validate(visited, append(path, "ExternalRefType")...)...)

	// TODO: check for required/min/max/etc.

	return errs
}

func (o *ExternalRefType) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, ExternalRefType_AltDownloadLocation.ID, ExternalRefType_AltWebPage.ID, ExternalRefType_BinaryArtifact.ID, ExternalRefType_Bower.ID, ExternalRefType_BuildMeta.ID, ExternalRefType_BuildSystem.ID, ExternalRefType_CertificationReport.ID, ExternalRefType_Chat.ID, ExternalRefType_ComponentAnalysisReport.ID, ExternalRefType_Cwe.ID, ExternalRefType_Documentation.ID, ExternalRefType_DynamicAnalysisReport.ID, ExternalRefType_EolNotice.ID, ExternalRefType_ExportControlAssessment.ID, ExternalRefType_Funding.ID, ExternalRefType_IssueTracker.ID, ExternalRefType_License.ID, ExternalRefType_MailingList.ID, ExternalRefType_MavenCentral.ID, ExternalRefType_Metrics.ID, ExternalRefType_Npm.ID, ExternalRefType_Nuget.ID, ExternalRefType_Other.ID, ExternalRefType_PrivacyAssessment.ID, ExternalRefType_ProductMetadata.ID, ExternalRefType_PurchaseOrder.ID, ExternalRefType_QualityAssessmentReport.ID, ExternalRefType_ReleaseHistory.ID, ExternalRefType_ReleaseNotes.ID, ExternalRefType_RiskAssessment.ID, ExternalRefType_RuntimeAnalysisReport.ID, ExternalRefType_SecureSoftwareAttestation.ID, ExternalRefType_SecurityAdversaryModel.ID, ExternalRefType_SecurityAdvisory.ID, ExternalRefType_SecurityFix.ID, ExternalRefType_SecurityOther.ID, ExternalRefType_SecurityPenTestReport.ID, ExternalRefType_SecurityPolicy.ID, ExternalRefType_SecurityThreatModel.ID, ExternalRefType_SocialMedia.ID, ExternalRefType_SourceArtifact.ID, ExternalRefType_StaticAnalysisReport.ID, ExternalRefType_Support.ID, ExternalRefType_Vcs.ID, ExternalRefType_VulnerabilityDisclosureReport.ID, ExternalRefType_VulnerabilityExploitabilityAssessment.ID)...)

	return errs
}

func (o *HashAlgorithm) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, HashAlgorithm_Adler32.ID, HashAlgorithm_Blake2b256.ID, HashAlgorithm_Blake2b384.ID, HashAlgorithm_Blake2b512.ID, HashAlgorithm_Blake3.ID, HashAlgorithm_CrystalsDilithium.ID, HashAlgorithm_CrystalsKyber.ID, HashAlgorithm_Falcon.ID, HashAlgorithm_Md2.ID, HashAlgorithm_Md4.ID, HashAlgorithm_Md5.ID, HashAlgorithm_Md6.ID, HashAlgorithm_Other.ID, HashAlgorithm_Sha1.ID, HashAlgorithm_Sha224.ID, HashAlgorithm_Sha256.ID, HashAlgorithm_Sha384.ID, HashAlgorithm_Sha3224.ID, HashAlgorithm_Sha3256.ID, HashAlgorithm_Sha3384.ID, HashAlgorithm_Sha3512.ID, HashAlgorithm_Sha512.ID)...)

	return errs
}

func (o *IndividualElement) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.Element.Validate(visited, path...)...)

	errs = append(errs, validateInValues(path, o.ID, IndividualElement_NoAssertionElement.ID, IndividualElement_NoneElement.ID)...)

	return errs
}

func (o *IntegrityMethod) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	// TODO: check for required
	return errs
}

func (o *LifecycleScopeType) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, LifecycleScopeType_Build.ID, LifecycleScopeType_Design.ID, LifecycleScopeType_Development.ID, LifecycleScopeType_Other.ID, LifecycleScopeType_Runtime.ID, LifecycleScopeType_Test.ID)...)

	return errs
}

func (o *NamespaceMap) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	// TODO: check for required

	// TODO: check for required
	return errs
}

func (o *PackageVerificationCode) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.IntegrityMethod.Validate(visited, path...)...)

	if o.Algorithm.ID == "" {
		errs = append(errs, newValidationError(append(path, "Algorithm"), fmt.Errorf("required")))
	}
	errs = append(errs, o.Algorithm.Validate(visited, append(path, "Algorithm")...)...)

	// TODO: check for required

	// TODO: check for required/min/max/etc.

	return errs
}

func (o *PositiveIntegerRange) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	// TODO: check for required

	// TODO: check for required
	return errs
}

func (o *PresenceType) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, PresenceType_No.ID, PresenceType_NoAssertion.ID, PresenceType_Yes.ID)...)

	return errs
}

func (o *ProfileIdentifierType) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, ProfileIdentifierType_Ai.ID, ProfileIdentifierType_Build.ID, ProfileIdentifierType_Core.ID, ProfileIdentifierType_Dataset.ID, ProfileIdentifierType_ExpandedLicensing.ID, ProfileIdentifierType_Extension.ID, ProfileIdentifierType_Lite.ID, ProfileIdentifierType_Security.ID, ProfileIdentifierType_SimpleLicensing.ID, ProfileIdentifierType_Software.ID)...)

	return errs
}

func (o *Relationship) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.Element.Validate(visited, path...)...)

	errs = append(errs, o.Completeness.Validate(visited, append(path, "Completeness")...)...)

	// TODO: check for required

	if v, ok := o.From.(validator); ok {
		errs = append(errs, v.Validate(visited, append(path, "From")...)...)
	}

	if o.RelationshipType.ID == "" {
		errs = append(errs, newValidationError(append(path, "RelationshipType"), fmt.Errorf("required")))
	}
	errs = append(errs, o.RelationshipType.Validate(visited, append(path, "RelationshipType")...)...)

	// TODO: check for required

	for i, v := range o.Tos {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "Tos", strconv.Itoa(i))...)...)
		}
	}

	return errs
}

func (o *RelationshipCompleteness) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, RelationshipCompleteness_Complete.ID, RelationshipCompleteness_Incomplete.ID, RelationshipCompleteness_NoAssertion.ID)...)

	return errs
}

func (o *RelationshipType) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, RelationshipType_Affects.ID, RelationshipType_AmendedBy.ID, RelationshipType_AncestorOf.ID, RelationshipType_AvailableFrom.ID, RelationshipType_Configures.ID, RelationshipType_Contains.ID, RelationshipType_CoordinatedBy.ID, RelationshipType_CopiedTo.ID, RelationshipType_DelegatedTo.ID, RelationshipType_DependsOn.ID, RelationshipType_DescendantOf.ID, RelationshipType_Describes.ID, RelationshipType_DoesNotAffect.ID, RelationshipType_ExpandsTo.ID, RelationshipType_ExploitCreatedBy.ID, RelationshipType_FixedBy.ID, RelationshipType_FixedIn.ID, RelationshipType_FoundBy.ID, RelationshipType_Generates.ID, RelationshipType_HasAddedFile.ID, RelationshipType_HasAssessmentFor.ID, RelationshipType_HasAssociatedVulnerability.ID, RelationshipType_HasConcludedLicense.ID, RelationshipType_HasDataFile.ID, RelationshipType_HasDeclaredLicense.ID, RelationshipType_HasDeletedFile.ID, RelationshipType_HasDependencyManifest.ID, RelationshipType_HasDistributionArtifact.ID, RelationshipType_HasDocumentation.ID, RelationshipType_HasDynamicLink.ID, RelationshipType_HasEvidence.ID, RelationshipType_HasExample.ID, RelationshipType_HasHost.ID, RelationshipType_HasInput.ID, RelationshipType_HasMetadata.ID, RelationshipType_HasOptionalComponent.ID, RelationshipType_HasOptionalDependency.ID, RelationshipType_HasOutput.ID, RelationshipType_HasPrerequisite.ID, RelationshipType_HasProvidedDependency.ID, RelationshipType_HasRequirement.ID, RelationshipType_HasSpecification.ID, RelationshipType_HasStaticLink.ID, RelationshipType_HasTest.ID, RelationshipType_HasTestCase.ID, RelationshipType_HasVariant.ID, RelationshipType_InvokedBy.ID, RelationshipType_ModifiedBy.ID, RelationshipType_Other.ID, RelationshipType_PackagedBy.ID, RelationshipType_PatchedBy.ID, RelationshipType_PublishedBy.ID, RelationshipType_ReportedBy.ID, RelationshipType_RepublishedBy.ID, RelationshipType_SerializedInArtifact.ID, RelationshipType_TestedOn.ID, RelationshipType_TrainedOn.ID, RelationshipType_UnderInvestigationFor.ID, RelationshipType_UsesTool.ID)...)

	return errs
}

func (o *SpdxDocument) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.ElementCollection.Validate(visited, path...)...)

	if v, ok := o.DataLicense.(validator); ok {
		errs = append(errs, v.Validate(visited, append(path, "DataLicense")...)...)
	}

	for i, v := range o.Imports {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "Imports", strconv.Itoa(i))...)...)
		}
	}

	for i, v := range o.NamespaceMaps {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "NamespaceMaps", strconv.Itoa(i))...)...)
		}
	}

	return errs
}

func (o *SupportType) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, SupportType_Deployed.ID, SupportType_Development.ID, SupportType_EndOfSupport.ID, SupportType_LimitedSupport.ID, SupportType_NoAssertion.ID, SupportType_NoSupport.ID, SupportType_Support.ID)...)

	return errs
}

func (o *Tool) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.Element.Validate(visited, path...)...)

	return errs
}

func (o *DatasetConfidentialityLevelType) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, DatasetConfidentialityLevelType_Amber.ID, DatasetConfidentialityLevelType_Clear.ID, DatasetConfidentialityLevelType_Green.ID, DatasetConfidentialityLevelType_Red.ID)...)

	return errs
}

func (o *DatasetDatasetAvailabilityType) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, DatasetDatasetAvailabilityType_Clickthrough.ID, DatasetDatasetAvailabilityType_DirectDownload.ID, DatasetDatasetAvailabilityType_Query.ID, DatasetDatasetAvailabilityType_Registration.ID, DatasetDatasetAvailabilityType_ScrapingScript.ID)...)

	return errs
}

func (o *DatasetDatasetType) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, DatasetDatasetType_Audio.ID, DatasetDatasetType_Categorical.ID, DatasetDatasetType_Graph.ID, DatasetDatasetType_Image.ID, DatasetDatasetType_NoAssertion.ID, DatasetDatasetType_Numeric.ID, DatasetDatasetType_Other.ID, DatasetDatasetType_Sensor.ID, DatasetDatasetType_Structured.ID, DatasetDatasetType_Syntactic.ID, DatasetDatasetType_Text.ID, DatasetDatasetType_Timeseries.ID, DatasetDatasetType_Timestamp.ID, DatasetDatasetType_Video.ID)...)

	return errs
}

func (o *ExpandedlicensingLicenseAddition) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.Element.Validate(visited, path...)...)

	// TODO: check for required

	// TODO: check for required

	// TODO: check for required

	// TODO: check for required

	// TODO: check for required/min/max/etc.

	// TODO: check for required
	return errs
}

func (o *ExpandedlicensingListedLicenseException) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.ExpandedlicensingLicenseAddition.Validate(visited, path...)...)

	// TODO: check for required

	// TODO: check for required
	return errs
}

func (o *ExtensionCdxPropertyEntry) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	// TODO: check for required

	// TODO: check for required
	return errs
}

func (o *ExtensionExtension) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	return errs
}

func (o *SecurityCvssSeverityType) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, SecurityCvssSeverityType_Critical.ID, SecurityCvssSeverityType_High.ID, SecurityCvssSeverityType_Low.ID, SecurityCvssSeverityType_Medium.ID, SecurityCvssSeverityType_None.ID)...)

	return errs
}

func (o *SecurityExploitCatalogType) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, SecurityExploitCatalogType_Kev.ID, SecurityExploitCatalogType_Other.ID)...)

	return errs
}

func (o *SecuritySsvcDecisionType) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, SecuritySsvcDecisionType_Act.ID, SecuritySsvcDecisionType_Attend.ID, SecuritySsvcDecisionType_Track.ID, SecuritySsvcDecisionType_TrackStar.ID)...)

	return errs
}

func (o *SecurityVexJustificationType) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, SecurityVexJustificationType_ComponentNotPresent.ID, SecurityVexJustificationType_InlineMitigationsAlreadyExist.ID, SecurityVexJustificationType_VulnerableCodeCannotBeControlledByAdversary.ID, SecurityVexJustificationType_VulnerableCodeNotInExecutePath.ID, SecurityVexJustificationType_VulnerableCodeNotPresent.ID)...)

	return errs
}

func (o *SecurityVulnAssessmentRelationship) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.Relationship.Validate(visited, path...)...)

	if v, ok := o.SuppliedBy.(validator); ok {
		errs = append(errs, v.Validate(visited, append(path, "SuppliedBy")...)...)
	}

	if v, ok := o.SecurityAssessedElement.(validator); ok {
		errs = append(errs, v.Validate(visited, append(path, "SecurityAssessedElement")...)...)
	}

	// TODO: check for required

	// TODO: check for required

	// TODO: check for required
	return errs
}

func (o *SimplelicensingAnyLicenseInfo) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.Element.Validate(visited, path...)...)

	return errs
}

func (o *SimplelicensingLicenseExpression) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SimplelicensingAnyLicenseInfo.Validate(visited, path...)...)

	for i, v := range o.SimplelicensingCustomIdToUris {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "SimplelicensingCustomIdToUris", strconv.Itoa(i))...)...)
		}
	}

	// TODO: check for required

	// TODO: check for required
	return errs
}

func (o *SimplelicensingSimpleLicensingText) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.Element.Validate(visited, path...)...)

	// TODO: check for required
	return errs
}

func (o *SoftwareContentIdentifier) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.IntegrityMethod.Validate(visited, path...)...)

	if o.SoftwareContentIdentifierType.ID == "" {
		errs = append(errs, newValidationError(append(path, "SoftwareContentIdentifierType"), fmt.Errorf("required")))
	}
	errs = append(errs, o.SoftwareContentIdentifierType.Validate(visited, append(path, "SoftwareContentIdentifierType")...)...)

	// TODO: check for required
	return errs
}

func (o *SoftwareContentIdentifierType) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, SoftwareContentIdentifierType_Gitoid.ID, SoftwareContentIdentifierType_Swhid.ID)...)

	return errs
}

func (o *SoftwareFileKindType) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, SoftwareFileKindType_Directory.ID, SoftwareFileKindType_File.ID)...)

	return errs
}

func (o *SoftwareSbomType) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, SoftwareSbomType_Analyzed.ID, SoftwareSbomType_Build.ID, SoftwareSbomType_Deployed.ID, SoftwareSbomType_Design.ID, SoftwareSbomType_Runtime.ID, SoftwareSbomType_Source.ID)...)

	return errs
}

func (o *SoftwareSoftwarePurpose) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError

	errs = append(errs, validateInValues(path, o.ID, SoftwareSoftwarePurpose_Application.ID, SoftwareSoftwarePurpose_Archive.ID, SoftwareSoftwarePurpose_Bom.ID, SoftwareSoftwarePurpose_Configuration.ID, SoftwareSoftwarePurpose_Container.ID, SoftwareSoftwarePurpose_Data.ID, SoftwareSoftwarePurpose_Device.ID, SoftwareSoftwarePurpose_DeviceDriver.ID, SoftwareSoftwarePurpose_DiskImage.ID, SoftwareSoftwarePurpose_Documentation.ID, SoftwareSoftwarePurpose_Evidence.ID, SoftwareSoftwarePurpose_Executable.ID, SoftwareSoftwarePurpose_File.ID, SoftwareSoftwarePurpose_FilesystemImage.ID, SoftwareSoftwarePurpose_Firmware.ID, SoftwareSoftwarePurpose_Framework.ID, SoftwareSoftwarePurpose_Install.ID, SoftwareSoftwarePurpose_Library.ID, SoftwareSoftwarePurpose_Manifest.ID, SoftwareSoftwarePurpose_Model.ID, SoftwareSoftwarePurpose_Module.ID, SoftwareSoftwarePurpose_OperatingSystem.ID, SoftwareSoftwarePurpose_Other.ID, SoftwareSoftwarePurpose_Patch.ID, SoftwareSoftwarePurpose_Platform.ID, SoftwareSoftwarePurpose_Requirement.ID, SoftwareSoftwarePurpose_Source.ID, SoftwareSoftwarePurpose_Specification.ID, SoftwareSoftwarePurpose_Test.ID)...)

	return errs
}

func (o *BuildBuild) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.Element.Validate(visited, path...)...)

	// TODO: check for required

	// TODO: check for required

	// TODO: check for required

	// TODO: check for required

	for i, v := range o.BuildConfigSourceDigests {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "BuildConfigSourceDigests", strconv.Itoa(i))...)...)
		}
	}

	// TODO: check for required/min/max/etc.

	// TODO: check for required/min/max/etc.

	for i, v := range o.BuildEnvironments {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "BuildEnvironments", strconv.Itoa(i))...)...)
		}
	}

	for i, v := range o.BuildParameters {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "BuildParameters", strconv.Itoa(i))...)...)
		}
	}

	return errs
}

func (o *Agent) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.Element.Validate(visited, path...)...)

	return errs
}

func (o *Annotation) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.Element.Validate(visited, path...)...)

	if o.AnnotationType.ID == "" {
		errs = append(errs, newValidationError(append(path, "AnnotationType"), fmt.Errorf("required")))
	}
	errs = append(errs, o.AnnotationType.Validate(visited, append(path, "AnnotationType")...)...)

	// TODO: check for required

	// TODO: check for required

	if v, ok := o.Subject.(validator); ok {
		errs = append(errs, v.Validate(visited, append(path, "Subject")...)...)
	}

	return errs
}

func (o *Artifact) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.Element.Validate(visited, path...)...)

	// TODO: check for required

	for i, v := range o.OriginatedBys {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "OriginatedBys", strconv.Itoa(i))...)...)
		}
	}

	// TODO: check for required

	// TODO: check for required/min/max/etc.

	if v, ok := o.SuppliedBy.(validator); ok {
		errs = append(errs, v.Validate(visited, append(path, "SuppliedBy")...)...)
	}

	for _, v := range o.SupportLevels {
		errs = append(errs, v.Validate(visited, append(path, "SupportLevels")...)...)
	}

	// TODO: check for required
	return errs
}

func (o *Bundle) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.ElementCollection.Validate(visited, path...)...)

	// TODO: check for required
	return errs
}

func (o *Hash) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.IntegrityMethod.Validate(visited, path...)...)

	if o.Algorithm.ID == "" {
		errs = append(errs, newValidationError(append(path, "Algorithm"), fmt.Errorf("required")))
	}
	errs = append(errs, o.Algorithm.Validate(visited, append(path, "Algorithm")...)...)

	// TODO: check for required
	return errs
}

func (o *LifecycleScopedRelationship) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.Relationship.Validate(visited, path...)...)

	errs = append(errs, o.Scope.Validate(visited, append(path, "Scope")...)...)

	return errs
}

func (o *Organization) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.Agent.Validate(visited, path...)...)

	return errs
}

func (o *Person) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.Agent.Validate(visited, path...)...)

	return errs
}

func (o *SoftwareAgent) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.Agent.Validate(visited, path...)...)

	return errs
}

func (o *ExpandedlicensingConjunctiveLicenseSet) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SimplelicensingAnyLicenseInfo.Validate(visited, path...)...)

	for i, v := range o.ExpandedlicensingMembers {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "ExpandedlicensingMembers", strconv.Itoa(i))...)...)
		}
	}

	return errs
}

func (o *ExpandedlicensingCustomLicenseAddition) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.ExpandedlicensingLicenseAddition.Validate(visited, path...)...)

	return errs
}

func (o *ExpandedlicensingDisjunctiveLicenseSet) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SimplelicensingAnyLicenseInfo.Validate(visited, path...)...)

	for i, v := range o.ExpandedlicensingMembers {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "ExpandedlicensingMembers", strconv.Itoa(i))...)...)
		}
	}

	return errs
}

func (o *ExpandedlicensingExtendableLicense) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SimplelicensingAnyLicenseInfo.Validate(visited, path...)...)

	return errs
}

func (o *ExpandedlicensingIndividualLicensingInfo) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SimplelicensingAnyLicenseInfo.Validate(visited, path...)...)

	errs = append(errs, validateInValues(path, o.ID, ExpandedlicensingIndividualLicensingInfo_NoAssertionLicense.ID, ExpandedlicensingIndividualLicensingInfo_NoneLicense.ID)...)

	return errs
}

func (o *ExpandedlicensingLicense) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.ExpandedlicensingExtendableLicense.Validate(visited, path...)...)

	// TODO: check for required

	// TODO: check for required

	// TODO: check for required

	// TODO: check for required

	// TODO: check for required

	// TODO: check for required/min/max/etc.

	// TODO: check for required

	// TODO: check for required

	// TODO: check for required
	return errs
}

func (o *ExpandedlicensingListedLicense) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.ExpandedlicensingLicense.Validate(visited, path...)...)

	// TODO: check for required

	// TODO: check for required
	return errs
}

func (o *ExpandedlicensingOrLaterOperator) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.ExpandedlicensingExtendableLicense.Validate(visited, path...)...)

	if v, ok := o.ExpandedlicensingSubjectLicense.(validator); ok {
		errs = append(errs, v.Validate(visited, append(path, "ExpandedlicensingSubjectLicense")...)...)
	}

	return errs
}

func (o *ExpandedlicensingWithAdditionOperator) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SimplelicensingAnyLicenseInfo.Validate(visited, path...)...)

	if v, ok := o.ExpandedlicensingSubjectAddition.(validator); ok {
		errs = append(errs, v.Validate(visited, append(path, "ExpandedlicensingSubjectAddition")...)...)
	}

	if v, ok := o.ExpandedlicensingSubjectExtendableLicense.(validator); ok {
		errs = append(errs, v.Validate(visited, append(path, "ExpandedlicensingSubjectExtendableLicense")...)...)
	}

	return errs
}

func (o *ExtensionCdxPropertiesExtension) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.ExtensionExtension.Validate(visited, path...)...)

	for i, v := range o.ExtensionCdxPropertys {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "ExtensionCdxPropertys", strconv.Itoa(i))...)...)
		}
	}

	return errs
}

func (o *SecurityCvssV2VulnAssessmentRelationship) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SecurityVulnAssessmentRelationship.Validate(visited, path...)...)

	// TODO: check for required

	// TODO: check for required
	return errs
}

func (o *SecurityCvssV3VulnAssessmentRelationship) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SecurityVulnAssessmentRelationship.Validate(visited, path...)...)

	// TODO: check for required

	if o.SecuritySeverity.ID == "" {
		errs = append(errs, newValidationError(append(path, "SecuritySeverity"), fmt.Errorf("required")))
	}
	errs = append(errs, o.SecuritySeverity.Validate(visited, append(path, "SecuritySeverity")...)...)

	// TODO: check for required
	return errs
}

func (o *SecurityCvssV4VulnAssessmentRelationship) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SecurityVulnAssessmentRelationship.Validate(visited, path...)...)

	// TODO: check for required

	if o.SecuritySeverity.ID == "" {
		errs = append(errs, newValidationError(append(path, "SecuritySeverity"), fmt.Errorf("required")))
	}
	errs = append(errs, o.SecuritySeverity.Validate(visited, append(path, "SecuritySeverity")...)...)

	// TODO: check for required
	return errs
}

func (o *SecurityEpssVulnAssessmentRelationship) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SecurityVulnAssessmentRelationship.Validate(visited, path...)...)

	// TODO: check for required

	// TODO: check for required
	return errs
}

func (o *SecurityExploitCatalogVulnAssessmentRelationship) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SecurityVulnAssessmentRelationship.Validate(visited, path...)...)

	if o.SecurityCatalogType.ID == "" {
		errs = append(errs, newValidationError(append(path, "SecurityCatalogType"), fmt.Errorf("required")))
	}
	errs = append(errs, o.SecurityCatalogType.Validate(visited, append(path, "SecurityCatalogType")...)...)

	// TODO: check for required

	// TODO: check for required
	return errs
}

func (o *SecuritySsvcVulnAssessmentRelationship) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SecurityVulnAssessmentRelationship.Validate(visited, path...)...)

	if o.SecurityDecisionType.ID == "" {
		errs = append(errs, newValidationError(append(path, "SecurityDecisionType"), fmt.Errorf("required")))
	}
	errs = append(errs, o.SecurityDecisionType.Validate(visited, append(path, "SecurityDecisionType")...)...)

	return errs
}

func (o *SecurityVexVulnAssessmentRelationship) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SecurityVulnAssessmentRelationship.Validate(visited, path...)...)

	// TODO: check for required

	// TODO: check for required
	return errs
}

func (o *SecurityVulnerability) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.Artifact.Validate(visited, path...)...)

	// TODO: check for required

	// TODO: check for required

	// TODO: check for required
	return errs
}

func (o *SoftwareSoftwareArtifact) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.Artifact.Validate(visited, path...)...)

	for _, v := range o.SoftwareAdditionalPurposes {
		errs = append(errs, v.Validate(visited, append(path, "SoftwareAdditionalPurposes")...)...)
	}

	// TODO: check for required/min/max/etc.

	for i, v := range o.SoftwareContentIdentifiers {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "SoftwareContentIdentifiers", strconv.Itoa(i))...)...)
		}
	}

	// TODO: check for required

	errs = append(errs, o.SoftwarePrimaryPurpose.Validate(visited, append(path, "SoftwarePrimaryPurpose")...)...)

	return errs
}

func (o *Bom) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.Bundle.Validate(visited, path...)...)

	return errs
}

func (o *ExpandedlicensingCustomLicense) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.ExpandedlicensingLicense.Validate(visited, path...)...)

	return errs
}

func (o *SecurityVexAffectedVulnAssessmentRelationship) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SecurityVexVulnAssessmentRelationship.Validate(visited, path...)...)

	// TODO: check for required

	// TODO: check for required
	return errs
}

func (o *SecurityVexFixedVulnAssessmentRelationship) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SecurityVexVulnAssessmentRelationship.Validate(visited, path...)...)

	return errs
}

func (o *SecurityVexNotAffectedVulnAssessmentRelationship) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SecurityVexVulnAssessmentRelationship.Validate(visited, path...)...)

	// TODO: check for required

	// TODO: check for required

	errs = append(errs, o.SecurityJustificationType.Validate(visited, append(path, "SecurityJustificationType")...)...)

	return errs
}

func (o *SecurityVexUnderInvestigationVulnAssessmentRelationship) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SecurityVexVulnAssessmentRelationship.Validate(visited, path...)...)

	return errs
}

func (o *SoftwareFile) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SoftwareSoftwareArtifact.Validate(visited, path...)...)

	// TODO: check for required

	errs = append(errs, o.SoftwareFileKind.Validate(visited, append(path, "SoftwareFileKind")...)...)

	return errs
}

func (o *SoftwarePackage) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SoftwareSoftwareArtifact.Validate(visited, path...)...)

	// TODO: check for required

	// TODO: check for required

	// TODO: check for required

	// TODO: check for required

	// TODO: check for required
	return errs
}

func (o *SoftwareSbom) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.Bom.Validate(visited, path...)...)

	for _, v := range o.SoftwareSbomTypes {
		errs = append(errs, v.Validate(visited, append(path, "SoftwareSbomTypes")...)...)
	}

	return errs
}

func (o *SoftwareSnippet) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SoftwareSoftwareArtifact.Validate(visited, path...)...)

	if v, ok := o.SoftwareByteRange.(validator); ok {
		errs = append(errs, v.Validate(visited, append(path, "SoftwareByteRange")...)...)
	}

	if v, ok := o.SoftwareLineRange.(validator); ok {
		errs = append(errs, v.Validate(visited, append(path, "SoftwareLineRange")...)...)
	}

	if v, ok := o.SoftwareSnippetFromFile.(validator); ok {
		errs = append(errs, v.Validate(visited, append(path, "SoftwareSnippetFromFile")...)...)
	}

	return errs
}

func (o *AiAIPackage) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SoftwarePackage.Validate(visited, path...)...)

	errs = append(errs, o.AiAutonomyType.Validate(visited, append(path, "AiAutonomyType")...)...)

	// TODO: check for required/min/max/etc.

	if v, ok := o.AiEnergyConsumption.(validator); ok {
		errs = append(errs, v.Validate(visited, append(path, "AiEnergyConsumption")...)...)
	}

	for i, v := range o.AiHyperparameters {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "AiHyperparameters", strconv.Itoa(i))...)...)
		}
	}

	// TODO: check for required

	// TODO: check for required

	// TODO: check for required

	for i, v := range o.AiMetrics {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "AiMetrics", strconv.Itoa(i))...)...)
		}
	}

	for i, v := range o.AiMetricDecisionThresholds {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "AiMetricDecisionThresholds", strconv.Itoa(i))...)...)
		}
	}

	// TODO: check for required/min/max/etc.

	// TODO: check for required/min/max/etc.

	errs = append(errs, o.AiSafetyRiskAssessment.Validate(visited, append(path, "AiSafetyRiskAssessment")...)...)

	// TODO: check for required/min/max/etc.

	// TODO: check for required/min/max/etc.

	errs = append(errs, o.AiUseSensitivePersonalInformation.Validate(visited, append(path, "AiUseSensitivePersonalInformation")...)...)

	return errs
}

func (o *DatasetDatasetPackage) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil {
		visited = map[any]struct{}{}
	}
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
	errs = append(errs, o.SoftwarePackage.Validate(visited, path...)...)

	// TODO: check for required/min/max/etc.

	errs = append(errs, o.DatasetConfidentialityLevel.Validate(visited, append(path, "DatasetConfidentialityLevel")...)...)

	// TODO: check for required

	// TODO: check for required/min/max/etc.

	errs = append(errs, o.DatasetDatasetAvailability.Validate(visited, append(path, "DatasetDatasetAvailability")...)...)

	// TODO: check for required

	// TODO: check for required

	if len(o.DatasetDatasetTypes) < 1 {
		errs = append(errs, newValidationError(append(path, "DatasetDatasetTypes"), fmt.Errorf("required min count: %v", 1)))
	}
	for _, v := range o.DatasetDatasetTypes {
		errs = append(errs, v.Validate(visited, append(path, "DatasetDatasetTypes")...)...)
	}

	// TODO: check for required

	errs = append(errs, o.DatasetHasSensitivePersonalInformation.Validate(visited, append(path, "DatasetHasSensitivePersonalInformation")...)...)

	// TODO: check for required

	// TODO: check for required/min/max/etc.

	for i, v := range o.DatasetSensors {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "DatasetSensors", strconv.Itoa(i))...)...)
		}
	}

	return errs
}
